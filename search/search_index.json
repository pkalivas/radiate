{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"User Guide","text":"<p>Radiate is a powerful library for implementing genetic algorithms and artificial evolution techniques. It provides a fast and flexible framework for creating, evolving, and optimizing solutions to complex problems using principles inspired by natural selection and genetics. The core is written in Rust and is available for Python.</p> <ul> <li> <p>Ease of use </p> <p>Intuitive API design allows users to easily configure and run genetic algorithms without needed to know the nuts and bolts of the complex operations underlying them.</p> </li> <li> <p>Modular Design </p> <p>The library architecture enables users to mix and match different components such as selection strategies, crossover methods, and mutation techniques to suit their specific needs.</p> </li> <li> <p>Performance </p> <p>Between Rust's performance capabilities, a multi-threaded architecture, and hours spent optimizing code, Radiate ensures efficient execution of genetic operations, even for large populations and complex problem spaces. </p> </li> <li> <p>Flexibility </p> <p>Out of the box support for a customizable genotypes and fitness functions, Radiate can be adapted to a wide range of problem domains, from single and multi optimization tasks to neuroevolution and machine learning applications.</p> </li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Genetic Engine: The central component orchestrating the genetic algorithm. It manages the ecosystem, evaluates fitness, and handles selection, crossover, and mutation processes. It is designed to be flexible and extensible, allowing customization to fit specific optimization requirements.</p> </li> <li> <p>Codec: Responsible for encoding and decoding genetic information. It acts as a bridge between the problem space and the solution space, allowing the genetic algorithm to operate on abstract genetic representations while solving real-world problems.</p> </li> <li> <p>Selectors: Used to choose individuals for reproduction and survival. They play a crucial role in determining the evolutionary pressure applied to the population.</p> </li> <li> <p>Alterers: Crossover and mutation operators that introduce genetic diversity and enable exploration of the solution space. The library provides a variety of built-in alterers.</p> </li> <li> <p>Fitness Function: Evaluates how well an individual solves the problem at hand. It is a critical component that guides the evolutionary process by assigning scores to individuals based on their performance.</p> </li> </ul>"},{"location":"#example","title":"Example","text":"<p>This simple maximizing problem demonstrates how to use Radiate to solve a string matching problem, where the goal is to evolve a genotype of chars to match a target string.</p> <p>Hello, Radiate!</p>  Python Rust <pre><code>import radiate as rd \n\ntarget = \"Hello, Radiate!\"\n\ndef fitness_func(x: list[str]) -&gt; int:\n    return sum(1 for i in range(len(target)) if x[i] == target[i])\n\nengine = rd.GeneticEngine(\n    codec=rd.CharCodec.vector(len(target)),\n    fitness_func=fitness_func,\n    offspring_selector=rd.BoltzmannSelector(4),\n)\n\nresult = engine.run(rd.ScoreLimit(len(target)))\n\nprint(result)\n</code></pre> <pre><code>use radiate::*;\n\nfn main() {\n    let target = \"Hello, Radiate!\";\n\n    let mut engine = GeneticEngine::builder()\n        .codec(CharCodec::vector(target.len()))\n        .offspring_selector(BoltzmannSelector::new(4_f32))\n        .fitness_fn(|geno: Vec&lt;char&gt;| {\n            geno.into_iter().zip(target.chars()).fold(\n                0,\n                |acc, (allele, targ)| {\n                    if allele == targ { acc + 1 } else { acc }\n                },\n            )\n        })\n        .build();\n\n    let result = engine.run(|generation| {\n        let best_as_string = generation.value().iter().collect::&lt;String&gt;();\n        println!(\"[ {:?} ]: {:?}\", generation.index(), best_as_string);\n\n        generation.score().as_usize() == target.len()\n    });\n\n    println!(\"{:?}\", result); \n}\n</code></pre>"},{"location":"#outside-inspirations","title":"Outside Inspirations","text":"<p>Radiate is inspired from a multitude of other genetic algorithm libraries, all of which have their own unique features and capabilities. Some of the most notable inspirations include:</p> <ul> <li>carrot: An architecture-free neural network library built around neuroevolution built in javascript.</li> <li>Genevo: A Rust library which provides building blocks to run simulations of optimization and search problems using genetic algorithms (GA).</li> <li>Sharpneat: A C# library for evolutionary computation, primarily focused on neuroevolution and artificial neural networks.</li> <li>Jenetics: A Genetic Algorithm, Evolutionary Algorithm, Grammatical Evolution, Genetic Programming, and Multi-objective Optimization library, written in modern day Java.</li> </ul>"},{"location":"#research-references","title":"Research &amp; References","text":"<p>For those interested in diving deeper into the concepts and theories behind genetic algorithms and evolutionary computation, here are some recommended research papers and books that have influenced the development of Radiate:</p> <ul> <li>Genetic Algorithms in Search, Optimization, and Machine Learning by David E. Goldberg: A foundational text that covers the principles and applications of genetic algorithms.</li> <li>Genetic Algorithms by K.F. Man, K.S. Tang, and S. Kwong: A comprehensive book that covers the fundamental concepts and techniques of genetic algorithms.</li> </ul>"},{"location":"source/events/","title":"Events and Subscriptions","text":"<p>Radiate provides an event system that allows you to monitor and react to the evolution process in real-time. This is great for:</p> <ul> <li>Tracking the progress of evolution</li> <li>Collecting metrics and statistics</li> <li>Implementing custom logging or logic based on the state of evolution</li> <li>Visualizing the evolution process</li> </ul>"},{"location":"source/events/#overview","title":"Overview","text":"<p>The event system in Radiate is built around the concept of event handlers or subscribers that can be attached to the <code>GeneticEngine</code>. These subscribers receive events at key points during the evolution process, allowing you to monitor and react to changes in the environment in real-time. The event system is designed to be flexible and extensible, allowing you to create custom event handlers that can perform various actions based on the evolution state.</p> <p>The <code>GeneticEngine</code> trys it's best to off-load almost the entire compute workload of the subscribers (handlers) to the user - be aware of this when implementing your handlers.</p> <p>Threading Behavior</p> <p>Currently, the rust implementation is multi-threaded (if multi-threaded executors are used), meaning if you have multiple subscribers, there is no guarantee of the order in which they will be called. For python, regardless of if you are using a free-threaded interpreter (3.13t/3.14t, ect) or not, the events will be dispatched on a single thread in the order they were added.</p>"},{"location":"source/events/#event-types","title":"Event Types","text":"<p>Radiate provides several key events that you can subscribe to. Here is the actual enum definition in Rust:</p> <pre><code>pub enum EngineEvent&lt;T&gt; {\n    /// Triggered when the evolution process starts.\n    /// Has no associated data, is simply a signal that evolution has begun.\n    Start,\n    /// Triggered when the evolution process stops. Provides the best individual, metrics, and score.\n    Stop(usize, T, MetricSet, Score),\n    /// Triggered at the start of each epoch with the epoch index.\n    EpochStart(usize),\n    /// Triggered at the end of each epoch with the epoch index, best individual, metrics, and score.\n    EpochComplete(usize, T, MetricSet, Score, Objective),\n    /// Triggered when an improvement is found with the epoch index, best individual, and score.\n    Improvement(usize, T, Score),\n}\n</code></pre> <p>Below there is a brief description of each event type with its representative data structures expressed in json.</p> Start Event <p>This event is triggered when the evolution process starts. It provides an opportunity to initialize any resources or perform setup tasks before the evolution begins.</p> <pre><code>{\n    'event_type': 'start_event'\n}\n</code></pre> Stop Event <p>This event is triggered when the evolution process stops, either due to reaching a stopping condition or being manually stopped. It provides access to:</p> <ul> <li>The final <code>metrics</code> of the evolution</li> <li>The best individual found</li> <li>The final <code>score</code>, or fitness, of the best individual</li> </ul> <pre><code>{\n    'event_type': 'stop_event',\n    'index': 0, // Current generation number\n    // This will be a MetricSet (or dictionary in python) of metrics collected, see Engine's metrics docs for more info\n    'metrics': ..., \n    // This will be the decoded best individual found so far. So, if you are \n    // evolving a vector of FloatGenes, this will be a list of floats\n    'best': [3.9699993,  1.5489225, -1.7164116,  1.0756674, -1.932127 , -2.3247557], \n    'score': 0.3327971398830414\n}\n</code></pre> Epoch Start Event <p>This event is triggered at the start of each generation (epoch) and provides the current generation number. It allows you to perform actions before the evolution step begins, such as resetting counters or logging initial state.</p> <pre><code>{\n    'event_type': 'epoch_start_event',\n    'index': 0  // Current generation number\n}\n</code></pre> Epoch Complete Event <p>This event is triggered at the end of each generation (epoch) and provides information about:</p> <ul> <li>The current generation number</li> <li>The current <code>metrics</code> from the <code>GeneticEngine</code></li> <li>The best individual found from the <code>GeneticEngine</code> so far</li> <li>The best <code>score</code>, or fitness, from the best individual</li> </ul> <pre><code>{\n    'event_type': 'epoch_complete_event',\n    'index': 0, // Current generation number\n    // This will be the current metrics collected, see Engine's metrics docs for more info\n    'metrics': ..., \n    // This will be the decoded best individual found so far. So, if you are \n    // evolving a vector of FloatGenes, this will be a list of floats\n    'best': [3.9699993,  1.5489225, -1.7164116,  1.0756674, -1.932127 , -2.3247557], \n    'score': 0.3327971398830414,\n    'objective': ['min']  // The optimization objective(s) used in this run\n}\n</code></pre> Engine Improvement Event <p>This event is triggered when the engine finds a new best individual during the evolution process. It provides:</p> <ul> <li>The index of the generation where the improvement occurred</li> <li>The best individual found at that point</li> <li>The <code>score</code>, or fitness, of the best individual</li> </ul> <pre><code>{\n    'event_type': 'engine_improvement_event',\n    'index': 0, // Current generation number\n    // This will be the decoded best individual found so far. So, if you are \n    // evolving a vector of FloatGenes, this will be a list of floats\n    'best': [3.9699993,  1.5489225, -1.7164116,  1.0756674, -1.932127 , -2.3247557], \n    'score': 0.3327971398830414\n}\n</code></pre>"},{"location":"source/events/#subscribing-to-events","title":"Subscribing to Events","text":"<p>You can subscribe to events in two ways:</p>"},{"location":"source/events/#callback-function","title":"Callback Function","text":"<p>The simplest way to subscribe to events is by providing a callback function:</p>  Python Rust <pre><code>import radiate as rd\n\nengine = rd.GeneticEngine(\n    codec=your_codec,\n    fitness_func=your_fitness_func,\n    # Subscribe to all events using a lambda function\n    subscribe=lambda event: print(event),  \n    # ... other parameters ...\n)\n\n# or add it later\nengine.subscribe(lambda event: print(event))\n\n# Run the engine\nengine.run(rd.GenerationsLimit(100))\n</code></pre> <pre><code>use radiate::*;\n\nlet mut engine = GeneticEngine::builder()\n    .codec(FloatCodec::vector(6, -5.0..5.0))\n    .fitness_fn(your_fitness_fn)\n    .subscribe(|event: &amp;EngineEvent&lt;Vec&lt;f32&gt;&gt;| {\n        if let EngineEvent::EpochComplete(index, best, metrics, score, objective) = event {\n            println!(\"Printing from event handler! [ {:?} ]: {:?}\", index, score);\n        }\n    })\n    // ... other parameters ...\n    .build();\n\n// Run the engine\nlet result = engine.run(|generation| {\n    generation.index() &gt;= 100\n});\n</code></pre>"},{"location":"source/events/#event-handler-class","title":"Event Handler Class","text":"<p>For more complex event handling, you can create a custom event handler class:</p>  Python Rust <pre><code>import radiate as rd\n\n# Inherit from EventHandler, tell the super class which event you'd like to subscribe to, \n# then override the on_event method\nclass Subscriber(rd.EventHandler):\n    def __init__(self):\n        super().__init__(rd.EventType.EPOCH_COMPLETE)\n\n    def on_event(self, event):\n        print(f\"Event: {event}\")\n\n# Create an instance of your event handler\nhandler = Subscriber()\n\nengine = rd.GeneticEngine(\n    codec=your_codec,\n    fitness_func=your_fitness_func,\n    subscribe=handler,\n    # ... other parameters ...\n)\n\n# or add it later\nengine.subscribe(handler)\n\n# Run the engine for 100 generations\nengine.run(rd.GenerationsLimit(100))\n</code></pre> <p>Its also completely possible to create more advanced forms of visualization or logging through this method. For example, below we will collect the scores from each epoch then use polars to create a DataFrame and finally plot it with matplotlib.</p> <pre><code>class ScorePlotterHandler(rd.EventHandler):\n    \"\"\"\n    An event handler that collects best scores over epochs and plots them at the end.\n    1. On EPOCH_COMPLETE, it appends the best score to a list.\n    2. On STOP, it creates a DataFrame and plots the scores over generations.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__() # Not specifying an event type to listen to all events\n        self.scores = []\n\n    def on_event(self, event: rd.EngineEvent) -&gt; None:\n        if event.event_type() == rd.EventType.EPOCH_COMPLETE:\n            best_score = event.score()\n            self.scores.append(best_score)\n        elif event.event_type() == rd.EventType.STOP:\n            df = pl.DataFrame(\n                {\"Generation\": list(range(len(self.scores))), \"Score\": self.scores}\n            )\n            plt.plot(df[\"Generation\"], df[\"Score\"])\n            plt.xlabel(\"Generation\")\n            plt.ylabel(\"Best Score\")\n            plt.title(\"Best Score over Generations\")\n            plt.grid(True)\n            plt.show()\n\n# Create an instance of your event handler\nhandler = ScorePlotterHandler()\n\nengine = rd.GeneticEngine(\n    codec=your_codec,\n    fitness_func=your_fitness_func,\n    subscribe=handler,\n    # ... other parameters ...\n)\n\n# or add it later\nengine.subscribe(handler)\n\n# Run the engine for 100 generations\nengine.run(rd.GenerationsLimit(100))\n</code></pre> <pre><code>use radiate::*;\n\nstruct MyHandler;\n\nimpl EventHandler&lt;Vec&lt;f32&gt;&gt; for MyHandler {\n    fn handle(&amp;mut self, event: Arc&lt;EngineEvent&lt;Vec&lt;f32&gt;&gt;&gt;) {\n        if let EngineEvent::EpochComplete(index, best, metrics, score, objective) = event.as_ref() {\n            println!(\"Printing from event handler! [ {:?} ]: {:?}\", index, score);\n        }\n    }\n}\n\n// Create and configure the engine\nlet mut engine = GeneticEngine::builder()\n    .codec(FloatCodec::vector(6, -5.0..5.0))\n    .subscribe(MyHandler)   // Add your handler here\n    .fitness_fn(your_fitness_fn)\n    // ... other parameters ...\n    .build();\n\n// Run the engine\nlet result = engine.run(|generation| {\n    generation.index() &gt;= 100\n});\n</code></pre>"},{"location":"source/events/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Keep Event Handlers Light:</p> <ul> <li>Event handlers are called frequently during evolution</li> <li>Avoid heavy computations in event handlers</li> </ul> </li> <li> <p>Use Multiple Subscribers:</p> <ul> <li>You can subscribe multiple handlers to the same engine</li> <li>Separate concerns into different handlers<ul> <li>Example: one for logging, one for metrics, one for visualization</li> </ul> </li> </ul> </li> <li> <p>Handle Errors Gracefully:</p> <ul> <li>Event handlers should not crash the evolution process</li> <li>Log errors instead of raising exceptions - do not expect the <code>GeneticEngine</code> to throw exceptions</li> </ul> </li> <li> <p>Monitor Performance:</p> <ul> <li>Be aware that event handling adds some overhead depending on your implementation</li> <li>Use built in <code>metrics</code> to track certain metrics or performance characteristics if possible</li> <li>Be cautious of your implementation - consider disabling event handling in production if not essential</li> </ul> </li> </ol>"},{"location":"source/examples/","title":"Examples","text":"<p>Check the git repo examples for a more  comprehensive list of examples.</p>"},{"location":"source/examples/#minsum","title":"MinSum","text":"<p>Find a set of numbers that sum to the minimum value (0). The solution is represented as a vector of integers, and the fitness function calculates the sum of the integers. The goal is to minimize this sum to 0.</p> <p>For example, a solution could be:</p> <pre><code>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n</code></pre>  Python Rust <pre><code>import radiate as rd\n\nengine = rd.GeneticEngine(\n    codec=rd.IntCodec.vector(10, (0, 100)),\n    fitness_func=lambda x: sum(x),\n    offspring_selector=rd.EliteSelector(),\n    objective=\"min\",\n    alters=[\n        rd.SwapMutator(0.05),\n        rd.UniformCrossover(0.5),\n    ],\n)\n\nresult = engine.run(rd.ScoreLimit(0))\n\nprint(result)\n</code></pre> <pre><code>use radiate::*;\n\nconst MIN_SCORE: i32 = 0;\n\nlet mut engine = GeneticEngine::builder()\n    .codec(IntCodec::vector(10, 0..100))\n    .minimizing()\n    .offspring_selector(EliteSelector::new())\n    .mutator(SwapMutator::new(0.05))\n    .crossover(UniformCrossover::new(0.5))\n    .fitness_fn(|geno: Vec&lt;i32&gt;| geno.iter().sum::&lt;i32&gt;())\n    .build();\n\nlet result = engine.run(|epoch| {\n    println!(\"[ {:?} ]: {:?}\", epoch.index(), epoch.value());\n    epoch.score().as_i32() == MIN_SCORE\n});\n\nprintln!(\"{:?}\", result);\n</code></pre>"},{"location":"source/examples/#nqueens","title":"NQueens","text":"<p>Solve the classic N-Queens problem, where the goal is to place <code>n</code> queens on an <code>n x n</code> board such that no two queens threaten each other. By threatening each other, we mean that they are in the same row, column, or diagonal. The solution is represented as a single chromosome with <code>n</code> genes, where each gene represents the row position of a queen in its respective column. The fitness function calculates the number of pairs of queens that threaten each other, and the goal is to minimize this value to zero. </p> <p>For example, a solution for <code>n=8</code> would be:</p>  Python Rust <p>Use the <code>use_numpy</code> flag to get a <code>numpy.array</code> back when decoding the chromosome for the fitness function. If we use the numba package to compile the fitness function we can actually match the rust example in terms of speed (+/- a few milliseconds).</p> <pre><code>import numpy as np\nimport radiate as rd\nfrom numba import jit, i32\n\nN_QUEENS = 32\n\n@jit(int32(int32[:]), nopython=True) # add this decorator from numba to compile the fitness function to native C code.\ndef fitness_fn(queens: np.ndarray) -&gt; int:\n    \"\"\"Calculate the fitness score for the N-Queens problem.\"\"\"\n\n    i_indices, j_indices = np.triu_indices(N_QUEENS, k=1)\n\n    same_row = queens[i_indices] == queens[j_indices]\n\n    same_diagonal = np.abs(i_indices - j_indices) == np.abs(\n        queens[i_indices] - queens[j_indices]\n    )\n\n    return np.sum(same_row) + np.sum(same_diagonal)\n\nengine = rd.GeneticEngine(\n    codec=rd.IntCodec.vector(N_QUEENS, (0, N_QUEENS), use_numpy=True),\n    fitness_func=fitness_fn,\n    objective=\"min\",\n    offspring_selector=rd.BoltzmannSelector(4.0),\n    alters=[\n        rd.MultiPointCrossover(0.75, 2),\n        rd.UniformMutator(0.05)\n    ]\n)\n\nresult = engine.run(rd.ScoreLimit(0), log=False)\nprint(result)\n\nboard = result.value()\nfor i in range(N_QUEENS):\n    for j in range(N_QUEENS):\n        if board[j] == i:\n            print(\"Q \", end=\"\")\n        else:\n            print(\". \", end=\"\")\n    print()\n</code></pre> <pre><code>use radiate::*;\n\nconst N_QUEENS: usize = 45;\n\nfn main() {\n    random_provider::set_seed(12345);\n\n    let engine = GeneticEngine::builder()\n        .codec(IntChromosome::from((N_QUEENS, 0..N_QUEENS as i8)))\n        .minimizing()\n        .offspring_selector(BoltzmannSelector::new(4.0))\n        .crossover(MultiPointCrossover::new(0.75, 2))\n        .mutator(UniformMutator::new(0.05))\n        .fitness_fn(|queens: Vec&lt;i8&gt;| {\n            let mut score = 0;\n\n            for i in 0..N_QUEENS {\n                for j in (i + 1)..N_QUEENS {\n                    if queens[i] == queens[j] {\n                        score += 1;\n                    }\n                    if (i as i8 - j as i8).abs() == (queens[i] - queens[j]).abs() {\n                        score += 1;\n                    }\n                }\n            }\n\n            score\n        })\n        .build();\n\n    let result = engine.iter().logging().until_score(0).last().unwrap();\n\n    println!(\"Best Score: {:?}\", result);\n    println!(\"\\nResult Queens Board ({:.3?}):\", result.time());\n\n    let board = &amp;result.value();\n    for i in 0..N_QUEENS {\n        for j in 0..N_QUEENS {\n            if board[j] == i as i8 {\n                print!(\"Q \");\n            } else {\n                print!(\". \");\n            }\n        }\n        println!();\n    }\n}\n</code></pre>"},{"location":"source/examples/#rastrigin","title":"Rastrigin","text":"<p>The Rastrigin function is a non-convex function used as a benchmark test problem for optimization algorithms. The function is highly multimodal, with many local minima, making it challenging for optimization algorithms to find the global minimum.  It is defined as: $$ f(x) = A \\cdot n + \\sum_{i=1}^{n} \\left[ x_i^2 - A \\cdot \\cos(2 \\pi x_i) \\right] $$ where:</p> <ul> <li>\\( A \\) is a constant (typically set to 10)</li> <li>\\( n \\) is the number of dimensions (in this case 2)</li> <li>\\( x_i \\) are the input variables.</li> <li>The global minimum occurs at \\( x = 0 \\) for all dimensions, where the function value is \\( 0 \\).</li> </ul>  Python Rust <pre><code>import math\nimport radiate as rd\n\nA = 10.0\nRANGE = 5.12\nN_GENES = 2\n\ndef fitness_fn(x):\n    value = A * N_GENES\n    for i in range(N_GENES):\n        value += x[i]**2 - A * math.cos((2.0 * 3.141592653589793 * x[i]))\n    return value\n\ncodec = rd.FloatCodec.vector(2, (-5.12, 5.12))\nengine = rd.GeneticEngine(codec, fitness_fn)\n\nengine.minimizing()\nengine.alters([\n    rd.UniformCrossover(0.5),\n    rd.ArithmeticMutator(0.01)\n])\n\nprint(engine.run(rd.ScoreLimit(0.0001)))\n</code></pre> <pre><code>use radiate::*;\n\nconst MIN_SCORE: f32 = 0.00;\nconst MAX_SECONDS: f64 = 1.0;\nconst A: f32 = 10.0;\nconst RANGE: f32 = 5.12;\nconst N_GENES: usize = 2;\n\nlet mut engine = GeneticEngine::builder()\n    .codec(FloatCodec::vector(N_GENES, -RANGE..RANGE))\n    .minimizing()\n    .population_size(500)\n    .alter(alters!(\n        UniformCrossover::new(0.5),\n        ArithmeticMutator::new(0.01)\n    ))\n    .fitness_fn(move |genotype: Vec&lt;f32&gt;| {\n        let mut value = A * N_GENES as f32;\n        for i in 0..N_GENES {\n            value += genotype[i].powi(2) - A * (2.0 * std::f32::consts::PI * genotype[i]).cos();\n        }\n\n        value\n    })\n    .build();\n\nlet result = engine.run(|ctx| {\n    println!(\"[ {:?} ]: {:?}\", ctx.index, ctx.score().as_f32());\n    ctx.score().as_f32() &lt;= MIN_SCORE || ctx.seconds() &gt; MAX_SECONDS\n});\n\nprintln!(\"{:?}\", result);\n</code></pre>"},{"location":"source/examples/#dtlz1","title":"DTLZ1","text":"<p>The DTLZ1 problem is a well-known multiobjective optimization problem that is used to test the performance of multiobjective optimization algorithms. It is a 3-objective problem with 4 variables and is defined as:</p> \\[ \\begin{align*} \\text{minimize} \\quad &amp; f_1(x) = (1 + g) \\cdot x_1 \\cdot x_2 \\\\ \\text{minimize} \\quad &amp; f_2(x) = (1 + g) \\cdot x_1 \\cdot (1 - x_2) \\\\ \\text{minimize} \\quad &amp; f_3(x) = (1 + g) \\cdot (1 - x_1) \\\\ \\text{subject to} \\quad &amp; 0 \\leq x_i \\leq 1 \\quad \\text{for} \\quad i = 1, 2, 3, 4 \\\\ \\text{where} \\quad &amp; g = \\sum_{i=3}^{4} (x_i - 0.5)^2 \\end{align*} \\]  Python Rust <p>Again here we are using the numba crate to compile the fitness function down to native C - once again, this allows us to match the same speed as rust.</p> <pre><code>import matplotlib.pyplot as plt\nimport radiate as rd\nimport numpy as np\nfrom numba import jit, float32\n\nrd.random.seed(501)\n\nvariables = 4\nobjectives = 3\nk = variables - objectives + 1\n\n# Because we are using numpy arrays, we can use numba to compile this function to native code for speed.\n# This allows us to match the speed of the rust implementation.\n@jit(float32[:](float32[:]), nopython=True)\ndef dtlz_1(val: np.ndarray) -&gt; np.ndarray:\n    g_vals = val[variables - k :] - 0.5\n    g = 100.0 * (k + np.sum(g_vals**2 - np.cos(20.0 * np.pi * g_vals)))\n\n    base = 0.5 * (1.0 + g)\n\n    f = np.full(objectives, base, dtype=np.float32)\n\n    for i in range(objectives):\n        prod_end = objectives - 1 - i\n        if prod_end &gt; 0:\n            f[i] *= np.prod(val[:prod_end])\n\n        if i &gt; 0:\n            f[i] *= 1.0 - val[objectives - 1 - i]\n\n    return f\n\n\nengine = rd.GeneticEngine(\n    codec=rd.FloatCodec.vector(variables, (0.0, 1.0), use_numpy=True),\n    fitness_func=dtlz_1,\n    offspring_selector=rd.TournamentSelector(k=8),\n    survivor_selector=rd.NSGA2Selector(),\n    objective=[\"min\" for _ in range(objectives)],\n    alters=[\n        rd.SimulatedBinaryCrossover(1.0, 2.0),\n        rd.UniformMutator(0.1),\n    ],\n)\n\nresult = engine.run(rd.GenerationsLimit(2000), ui=True)\n\n# When running an MO problem, we can get the resulting pareto from from the \n# engine's epoch result. This is stored in the 'front()' field of the result here:\nfront = result.front()\n\nfig = plt.figure()\nax = plt.axes(projection=\"3d\")\n\nx = [member.score()[0] for member in front]\ny = [member.score()[1] for member in front]\nz = [member.score()[2] for member in front]\n\nax.scatter(x, y, z)\nax.set_xlim([0, 0.5])\nax.set_ylim([0, 0.5])\nax.set_zlim([0, 0.5])\nplt.show()\n</code></pre> <pre><code>use radiate::*;\n\npub fn dtlz_1(values: &amp;[f32]) -&gt; Vec&lt;f32&gt; {\n    let mut g = 0.0;\n    for i in VARIABLES - K..VARIABLES {\n        g += (values[i] - 0.5).powi(2) - (20.0 * std::f32::consts::PI * (values[i] - 0.5)).cos();\n    }\n\n    g = 100.0 * (K as f32 + g);\n\n    let mut f = vec![0.0; OBJECTIVES];\n    for i in 0..OBJECTIVES {\n        f[i] = 0.5 * (1.0 + g);\n        for j in 0..OBJECTIVES - 1 - i {\n            f[i] *= values[j];\n        }\n\n        if i != 0 {\n            f[i] *= 1.0 - values[OBJECTIVES - 1 - i];\n        }\n    }\n\n    f\n}\n\nconst VARIABLES: usize = 4;\nconst OBJECTIVES: usize = 3;\nconst K: usize = VARIABLES - OBJECTIVES + 1;\n\nlet codec = FloatCodec::vector(VARIABLES, 0_f32..1_f32).with_bounds(-100.0, 100.0);\n\nlet mut engine = GeneticEngine::builder()\n    .codec(codec)\n    .multi_objective(vec![Optimize::Minimize; OBJECTIVES])\n    .offspring_selector(TournamentSelector::new(5))\n    .survivor_selector(NSGA2Selector::new())\n    .alter(alters!(\n        SimulatedBinaryCrossover::new(1_f32, 1.0),\n        UniformMutator::new(0.1),\n    ))\n    .fitness_fn(|geno: Vec&lt;f32&gt;| dtlz_1(&amp;geno))\n    .build();\n\nlet result = engine.run(|ctx| {\n    println!(\"[ {:?} ]\", ctx.index);\n    ctx.index &gt; 1000\n});\n\n// When running an MO problem, we can get the resulting pareto from from the \n// engine's epoch result. This is stored in the 'front()' field of the result here:\nlet front = result.front();\n</code></pre> <p>The resulting Pareto front can be visualized using Plotly or matplotlib, as shown below:</p>"},{"location":"source/examples/#graph-xor-problem","title":"Graph - XOR Problem","text":"<p>Evolve a <code>Graph&lt;Op&lt;f32&gt;&gt;</code> to solve the XOR problem (NeuroEvolution).</p>  Python Rust <pre><code>import radiate as rd\n\ninputs = [[0.0, 0.0], [1.0, 1.0], [1.0, 0.0], [0.0, 1.0]]\nanswers = [[0.0], [0.0], [1.0], [1.0]]\n\ncodec = rd.GraphCodec.directed(\n    shape=(2, 1),\n    vertex=[rd.Op.add(), rd.Op.mul(), rd.Op.linear()],\n    edge=rd.Op.weight(),\n    output=rd.Op.linear(),\n)\n\nengine = rd.GeneticEngine(\n    codec=codec,\n    fitness_fn=rd.Regression(inputs, answers, loss='mse'),\n    objective=\"min\",\n    alters=[\n        rd.GraphCrossover(0.5, 0.5),\n        rd.OperationMutator(0.07, 0.05),\n        rd.GraphMutator(0.1, 0.1),\n    ],\n)\n\nresult = engine.run([rd.ScoreLimit(0.001), rd.GenerationsLimit(1000)], log=True)\n\nfor input, target in zip(inputs, answers):\n    print(f\"Input: {input}, Target: {target}, Output: {result.value().eval([input])}\")\n</code></pre> <p>Requires <code>gp</code> feature flag</p> <pre><code>use radiate::*;\n\nconst MAX_INDEX: i32 = 500;\nconst MIN_SCORE: f32 = 0.01;\n\nfn main() {\n    random_provider::set_seed(501);\n\n    let store = vec![\n        (NodeType::Input, vec![Op::var(0), Op::var(1)]),\n        (NodeType::Edge, vec![Op::weight(), Op::identity()]),\n        (NodeType::Vertex, ops::all_ops()),\n        (NodeType::Output, vec![Op::sigmoid()]),\n    ];\n\n    let graph_codec = GraphCodec::directed(2, 1, store);\n    let regression = Regression::new(get_dataset(), Loss::MSE);\n\n    let engine = GeneticEngine::builder()\n        .codec(graph_codec)\n        .fitness_fn(regression)\n        .minimizing()\n        .alter(alters!(\n            GraphCrossover::new(0.5, 0.5),\n            OperationMutator::new(0.05, 0.05),\n            GraphMutator::new(0.06, 0.01).allow_recurrent(false),\n        ))\n        .build();\n\n    // Using the engine iterator\n    engine\n        .iter()\n        .logging()\n        .until_score(MIN_SCORE)\n        .last()\n        .inspect(display);\n}\n\nfn display(result: &amp;Generation&lt;GraphChromosome&lt;Op&lt;f32&gt;&gt;, Graph&lt;Op&lt;f32&gt;&gt;&gt;) {\n    let mut reducer = GraphEvaluator::new(result.value());\n    for sample in get_dataset().iter() {\n        let output = &amp;reducer.eval_mut(sample.input())[0];\n        println!(\n            \"{:?} -&gt; epected: {:?}, actual: {:.3?}\",\n            sample.input(),\n            sample.output(),\n            output\n        );\n    }\n\n    println!(\"{result:?}\");\n}\n\nfn get_dataset() -&gt; DataSet {\n    let inputs = vec![\n        vec![0.0, 0.0],\n        vec![1.0, 1.0],\n        vec![1.0, 0.0],\n        vec![0.0, 1.0],\n    ];\n\n    let answers = vec![vec![0.0], vec![0.0], vec![1.0], vec![1.0]];\n\n    DataSet::new(inputs, answers)\n}\n</code></pre>"},{"location":"source/examples/#tree-regression","title":"Tree - Regression","text":"<p>Evolve a <code>Tree&lt;Op&lt;f32&gt;&gt;</code> to solve the a regression problem (Genetic Programming).</p>  Python Rust <pre><code>import radiate as rd\n\ninputs = [[0.0, 0.0], [1.0, 1.0], [1.0, 0.0], [0.0, 1.0]]\nanswers = [[0.0], [0.0], [1.0], [1.0]]\n\ncodec = rd.TreeCodec(\n    shape=(2, 1),\n    vertex=[rd.Op.sub(), rd.Op.mul(), rd.Op.add()],\n    root=rd.Op.linear(),\n)\n\nengine = rd.GeneticEngine(\n    codec=codec,\n    fitness_func=rd.Regression(inputs, answers),\n    objective=\"min\",\n    alters=[\n        rd.TreeCrossover(0.7),\n        rd.HoistMutator(0.01),\n    ],\n)\n\nresult = engine.run([rd.ScoreLimit(0.01), rd.TimeLimit(1.0)], log=True)\nprint(result)\n\nfor input, target in zip(inputs, answers):\n    print(f\"Input: {input}, Target: {target}, Output: {result.value().eval([input])}\")\n</code></pre> <p>Requires <code>gp</code> feature flag</p> <pre><code>use radiate::*;\n\nconst MIN_SCORE: f32 = 0.01;\nconst MAX_SECONDS: f64 = 1.0;\n\nfn main() {\n    random_provider::set_seed(518);\n\n    let store = vec![\n        (NodeType::Vertex, vec![Op::add(), Op::sub(), Op::mul()]),\n        (NodeType::Leaf, vec![Op::var(0)]),\n    ];\n\n    let tree_codec = TreeCodec::single(3, store).constraint(|root| root.size() &lt; 30);\n    let regression = Regression::new(get_dataset(), Loss::MSE);\n\n    let mut engine = GeneticEngine::builder()\n        .codec(tree_codec)\n        .fitness_fn(regression)\n        .minimizing()\n        .mutator(HoistMutator::new(0.01))\n        .crossover(TreeCrossover::new(0.7))\n        .build();\n\n    let result = engine.run(|ctx| {\n        println!(\"[ {:?} ]: {:?}\", ctx.index, ctx.score().as_f32());\n        ctx.score().as_f32() &lt; MIN_SCORE || ctx.seconds() &gt; MAX_SECONDS\n    });\n\n    display(&amp;result);\n}\n\nfn display(result: &amp;Generation&lt;TreeChromosome&lt;Op&lt;f32&gt;&gt;, Tree&lt;Op&lt;f32&gt;&gt;&gt;) {\n    Accuracy::default()\n        .named(\"Regression Tree\")\n        .on(&amp;get_dataset())\n        .loss(Loss::MSE)\n        .eval(result.value())\n        .inspect(|acc| {\n            println!(\"{}\", result.metrics().dashboard());\n            println!(\"Best Tree: {}\", result.value().format());\n            println!(\"{:?}\", acc);\n        });\n}\n\nfn get_dataset() -&gt; DataSet {\n    let mut inputs = Vec::new();\n    let mut answers = Vec::new();\n\n    let mut input = -1.0;\n    for _ in -10..10 {\n        input += 0.1;\n        inputs.push(vec![input]);\n        answers.push(vec![compute(input)]);\n    }\n\n    DataSet::new(inputs, answers)\n}\n\nfn compute(x: f32) -&gt; f32 {\n    4.0 * x.powf(3.0) - 3.0 * x.powf(2.0) + x\n}\n</code></pre>"},{"location":"source/executors/","title":"Executors","text":"<p>During the process of evolution, various operations are pushed into an <code>executor</code> to be run. Things like evaluating fitness, dispatching events, etc. Executors are responsible for managing how these operations are run, whether that be in a single thread or multiple threads and how those threads are managed.</p> <p>Currently, radiate supports three executors:</p> <ul> <li><code>Serial</code>: Runs all operations in the main thread, one at a time.<ul> <li>This is the default executor if none is specified.</li> </ul> </li> <li><code>WorkerPool</code>: Uses a rayon thread pool to run operations concurrently.<ul> <li>note that in rust this requires the <code>rayon</code> feature to be enabled in <code>Cargo.toml</code>. Python includes this by default.</li> </ul> </li> <li><code>FixedSizedWorkerPool(num_threads)</code>: Uses an internal thread pool with a fixed number of threads to run operations concurrently.</li> </ul>"},{"location":"source/executors/#example","title":"Example","text":"<p>Continuing with our example from the preious sections - evolving a simple function: finding the best values for <code>y = ax + b</code> where we want to find optimal values for <code>a</code> and <code>b</code>. We'll keep the previous inputs the same as before, but now we add an <code>executor</code> to the <code>GeneticEngine</code>.</p>  Python Rust <p>Its important to note that the <code>WorkerPool</code> and <code>FixedSizedWorkerPool</code> executors use multiple threads to run the fitness function concurrently. If you are not using a free-threaded interpreter (ie: <code>python3.13t/3.14t</code>) or the GIL is enabled, these options will be replaced with the <code>Serial</code> executor. </p> <p>If you are in fact using a free-threaded interpreter, your engine can take advantage of multiple threads to evaluate fitness concurrently. This can significantly speed up evolution, especially if your fitness function is computationally expensive. However, your fitness function must be thread-safe.</p> <pre><code>import radiate as rd\n\n# Define a fitness function that uses the decoded values\ndef fitness_function(individual: list[float]) -&gt; float:    \n    # Calculate how well these parameters fit your data\n    a = individual[0]\n    b = individual[1]\n    return calculate_error(a, b)  # Your error calculation here\n\n# Create a codec for two parameters (a and b)\ncodec = rd.FloatCodec.vector(\n    length=2,                  # We need two parameters: a and b\n    init_range=(-1.0, 1.0),    # Start with values between -1 and 1\n    bounds=(-10.0, 10.0)       # Allow evolution to modify the values between -10 and 10\n)\n\n# Use Boltzmann selection for offspring - individuals which\n# will be used to create new individuals through mutation and crossover\noffspring_selector = rd.BoltzmannSelector(temp=4)\n\n# Use tournament selection for survivors - individuals which will \n# be passed down unchanged to the next generation\nsurvivor_selector = rd.TournamentSelector(k=3)\n\n# Define the alterers - these will be applied to the selected offspring\n# to create new individuals. They will be applied in the order they are defined.\nalters = [\n    rd.GaussianMutator(rate=0.1),\n    rd.BlendCrossover(rate=0.8, alpha=0.5)\n]\n\n# Define the diversity measure\ndiversity = rd.HammingDistance()  # or rd.EuclideanDistance() for continuous problems\n\n# Define the executor - here we use a fixed size worker pool with 4 threads\nexecutor = rd.Executor.FixedSizedWorkerPool(num_workers=4)\n# Alternatively, you can use a WorkerPool (which uses rayon's global thread pool)\nexecutor = rd.Executor.WorkerPool()\n# Or for single-threaded execution, use Serial - this is the default if none is specified\nexecutor = rd.Executor.Serial()\n\n# Create the evolution engine\nengine = rd.GeneticEngine(\n    codec=codec,\n    fitness_func=fitness_function,\n    offspring_selector=offspring_selector,\n    survivor_selector=survivor_selector,\n    alters=alters,\n    diversity=diversity,\n    species_threshold=0.5,\n    max_species_age=20,\n    executor=executor,  # Set the executor here\n    # ... other parameters ...\n)\n\n# Run the engine\nresult = engine.run([rd.ScoreLimit(0.01), rd.GenerationsLimit(1000)])\n</code></pre> <p>To use the <code>WorkerPool</code> executor in rust (which uses rayon), ensure you have the <code>rayon</code> feature enabled in your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nradiate = { version = \"x\", features = [\"rayon\"] }\n</code></pre> <pre><code>use radiate::*;\n\n// Define a fitness function that uses the decoded values\nfn fitness_fn(individual: Vec&lt;f32&gt;) -&gt; f32 {\n    let a = individual[0];\n    let b = individual[1];\n    calculate_error(a, b)  // Your error calculation here\n}\n\n// This will produce a Genotype&lt;FloatChromosome&gt; with 1 FloatChromosome which\n// holds 2 FloatGenes (a and b), each with a value between -1.0 and 1.0 and a bound between -10.0 and 10.0\nlet codec = FloatCodec::vector(2, -1.0..1.0).with_bounds(-10.0..10.0);\n\n// Use Boltzmann selection for offspring - individuals which\n// will be used to create new individuals through mutation and crossover\nlet offspring_selector = BoltzmannSelector::new(4.0);\n\n// Use tournament selection for survivors - individuals which will\n// be passed down unchanged to the next generation\nlet survivor_selector = TournamentSelector::new(3);\n\n// Define some alters \nlet alters = alters![\n    GaussianMutator::new(0.1),\n    BlendCrossover::new(0.8, 0.5)\n];\n\n// Define the diversity measure\nlet diversity = HammingDistance::new(); // or EuclideanDistance::new() for continuous problems\n\n// Define the executor - here we use a fixed size worker pool with 4 threads\nlet executor = Executor::FixedSizedWorkerPool(4);\n// Alternatively, you can use a WorkerPool (which uses rayon's global thread pool)\nlet executor = Executor::WorkerPool;\n// Or for single-threaded execution, use Serial - this is the default if none is specified\nlet executor = Executor::Serial;\n\nlet mut engine = GeneticEngine::builder()\n    .codec(codec)\n    .offspring_selector(offspring_selector)\n    .survivor_selector(survivor_selector)\n    .fitness_fn(fitness_fn)\n    .alterers(alters) \n    .diversity(diversity)  \n    .species_threshold(0.5)     \n    .max_species_age(20)        \n    .executor(executor)         // Set the executor here\n    // ... other parameters ...\n    .build();\n\n// Run the engine\nlet result = engine.run(|generation| {\n    // Now because we have added diversity, the ecosystem will include species like such:\n    let species = generation.species().unwrap();\n    println!(\"Species count: {}\", species.len());\n    generation.index() &gt;= 1000 || generation.score().as_f32() &lt;= 0.01\n});\n</code></pre> <p>You can also use the convenient <code>.parallel()</code> method on the engine builder. If the <code>rayon</code> feature is enabled, this will set the executor to <code>WorkerPool</code>, otherwise it will set it to <code>FixedSizedWorkerPool(std::thread::available_parallelism().unwrap().get())</code>.:</p> <pre><code>let mut engine = GeneticEngine::builder()\n    // ... other builder methods ...\n    .parallel() \n    .build();\n</code></pre>"},{"location":"source/fitness/","title":"Fitness Functions","text":"<p>Fitness functions are the core of any genetic algorithm - they define how well an individual performs and guide the evolution process. Radiate supports several different types of fitness functions, from your run of the mill functions to advanced techniques like novelty search and composite fitness functions.</p> <p>The fitness function takes a decoded phenotype (the actual data structure) and returns a <code>Score</code> that represents how well that individual performs. The score can be a single value for single-objective optimization or multiple values for multi-objective problems. The result of your fitness function should reflect the quality of the individual in relation to the problem being solved. </p> <p>Fitness functions must return valid scores</p> <p>All fitness functions must return a <code>Score</code> object. Radiate automatically converts common types like <code>f32</code>, <code>f64</code>, <code>i32</code>, <code>\u00ec64</code>, <code>Vec&lt;f32&gt;</code>, etc. into <code>Score</code> objects. NaN values are not allowed and will cause a panic. The number of values returned by the fitness function must match your objectives. For example, if you have two objectives, your fitness function must return a <code>Score</code> with two values.</p>"},{"location":"source/fitness/#overview","title":"Overview","text":"Fitness Function Type Purpose Use Case Complexity Simple Functions Basic optimization Problems, benchmarks, cutstom logic Low Batch Fitness Batch optimization Problems, benchmarks, custom logic Low Raw Fitness Direct genotype evaluation When decoding is unnecessary Low Composite Functions Fitness combination Balancing multiple goals Medium Novelty Search Behavioral diversity Exploration, avoiding local optima High"},{"location":"source/fitness/#simple-fitness","title":"Simple Fitness","text":"<p>Simple fitness functions are the most common type - they take a phenotype and return a single score value. These can be any function that evaluates how well an individual performs. Things like mathematical functions, benchmarks, or even custom evaluation logic can be used as simple fitness functions. Your run of the mill mathematical functions like Rastrigin, Sphere, or Ackley functions are great examples of simple fitness functions. They take a vector of floats and return a single float score.</p> <p> Python <code>numba</code></p> <p>For python, In some cases it is possible to compile your fitness function down to machine code using numba.  In most cases with this, this will result in your engine running as fast or almost as fast as rust. Check the examples page for an example using this method.</p>  Python Rust <pre><code>import radiate as rd\nimport math\n\nA = 10.0\nRANGE = 5.12\nN_GENES = 2\n\ndef fitness_fn(x: list[float]) -&gt; float:\n    value = A * N_GENES\n    for i in range(N_GENES):\n        value += x[i]**2 - A * math.cos((2.0 * 3.141592653589793 * x[i]))\n    return value\n\ncodec = rd.FloatCodec.vector(N_GENES, init_range=(-RANGE, RANGE))\nengine = rd.GeneticEngine(codec, fitness_fn, objective=\"min\")\n</code></pre> <pre><code>use radiate::*;\n\nfn rastrigin_function(genotype: Vec&lt;f32&gt;) -&gt; f32 {\n    let mut value = 10.0 * 2 as f32;\n    for i in 0..N_GENES {\n        value += genotype[i].powi(2) - 10.0 * (2.0 * std::f32::consts::PI * genotype[i]).cos();\n    }\n\n    value\n}\n\nlet engine = GeneticEngine::builder()\n    .codec(FloatCodec::vector(2, -5.12..5.12))\n    .minimizing()\n    .fitness_fn(rastrigin_function)\n    .build();\n</code></pre>"},{"location":"source/fitness/#batch-fitness","title":"Batch Fitness","text":"<p>The batch fitness function groups members of the <code>Population</code> which need to be evaluated into buckets to be evaluated together.  If you need access to parts or the whole of a <code>Population</code> in order to compute fitness, this is your best bet. Depending on the  implementation of your actual fitness logic, this can also be a speed up to your <code>Engine</code>. The logic behind the grouping depends on the <code>Executor</code> being used. Meaning, if your <code>Executor</code> is using 4 workers (threads) the individuals which need to be evaluated will be split into 4 batches. On the flip side, if your <code>Executor</code> is using a single thread (Serial), your fitness function will recieve a single batch containing all individuals which need evaluation.</p> <p>Its important to note that other types of fitness functions like <code>NoveltySearch</code> &amp; <code>CompositeFitnessFn</code> both support batch processing too by simply placing those objects within the call to <code>.batch_fitness_fn</code> - just like <code>.fitness_fn</code>.</p>  Python Rust <pre><code>import radiate as rd\nimport math\n\nA = 10.0\nRANGE = 5.12\nN_GENES = 2\n\n# NOTE this function expects a batch of inputs and returns a batch of outputs\n# the order in which the inputs are given is the order in which the outputs are returned\ndef fitness_fn(x: list[list[float]]) -&gt; list[float]:\n    assert len(x) &gt; 1\n\n    results = []\n    for member in x:\n        value = A * N_GENES\n        for i in range(N_GENES):\n            value += member[i]**2 - A * math.cos((2.0 * 3.141592653589793 * member[i]))\n        results.append(value)\n    return results\n\ncodec = rd.FloatCodec.vector(N_GENES, init_range=(-RANGE, RANGE))\n\n# Create the genetic engine with batch fitness function.\n# Just wrap your fitness function in 'rd.BatchFitness'\nengine = rd.GeneticEngine(codec, rd.BatchFitness(fitness_fn), objective=\"min\")\n</code></pre> <pre><code>use radiate::*;\n\nlet engine = GeneticEngine::builder()\n    .codec(IntChromosome::from((5, 0..100)))\n    // Replace the original 'fitness_fn' call with 'batch_fitness_fn' to enable batch fitness.\n    // This fitness function will receive a single batch containing all individuals which need evaluation\n    .batch_fitness_fn(|phenotypes: &amp;[Vec&lt;i32&gt;]| {\n        phenotypes\n            .iter()\n            .map(|geno| geno.iter().sum::&lt;i32&gt;())\n            .collect()\n    })\n    .build();\n\n// When using an parallel executor, the batches will be grouped together to evaluate on separate threads\nlet engine = GeneticEngine::builder()\n    .codec(IntChromosome::from((5, 0..100)))\n    // 'batch_fitness_fn' will receive 7 batches of individuals during each generation's evaluation\n    .executor(Executor::FixedSizedWorkerPool(7))\n    .batch_fitness_fn(|phenotypes: &amp;[Vec&lt;i32&gt;]| {\n        phenotypes\n            .iter()\n            .map(|geno| geno.iter().sum::&lt;i32&gt;())\n            .collect()\n    })\n    .build();\n</code></pre>"},{"location":"source/fitness/#raw-fitness","title":"Raw Fitness","text":"<p>Raw fitness functions provide direct access to the genotype in the fitness function. If your fitness function can operate directly on the <code>Genotype</code> without needing to decode it, you can use a raw fitness function.</p> <p>This can be a useful performance optimization in cases where decoding is unnecessary or when the genotype structure is simple enough to evaluate directly.</p>  Python Rust <p>Due to the rust-python bridge limitations, raw fitness functions are not currently supported in the python API.</p> <pre><code>use radiate::*;\n\nfn my_fitness_fn(genotype: &amp;Genotype&lt;FloatChromosome&gt;) -&gt; f32 {\n    // Evaluate the genotype directly without decoding\n    genotype.iter()\n        .map(|chromosome| chromosome.iter().map(|gene| *gene.allele()).sum::&lt;f32&gt;())\n        .sum::&lt;f32&gt;()\n}\n\nlet mut engine = GeneticEngine::builder()\n    .codec(FloatCodec::vector(10, 0.0..1.0))\n    .raw_fitness_fn(my_fitness_fn)\n    // or .raw_batch_fitness_fn(...) for batch raw fitness functions\n    // ... other parameters ...\n    .build();\n\n// Run the engine\nlet result = engine.run(|epoch| epoch.index() &gt;= 100);\n</code></pre>"},{"location":"source/fitness/#composite-fitness","title":"Composite Fitness","text":"<p>Composite fitness functions allow you to combine multiple objectives into a single weighted fitness score. This is useful when you have multiple goals that need to be balanced. There are two main options when using a <code>CompositeFitnessFn</code>:</p> <ol> <li> <p>Weighted </p> <ul> <li>Combine multiple fitness functions with weights to create a single weighted average objective.</li> </ul> </li> <li> <p>Equal</p> <ul> <li>Combine multiple fitness functions with equal weights (1.0) to produce a single objective.</li> </ul> </li> </ol>  Python Rust <p> Under Construction </p> <p>The composite fitness function is currently under construction and not yet available in the Python API.</p> <pre><code>use radiate::*;\n\nfn accuracy_objective(model: &amp;MyDecodedModel) -&gt; f32 {\n    // ... calculate accuracy ...\n}\n\nfn complexity_objective(model: &amp;MyDecodedModel) -&gt; f32 {\n    // ... calculate complexity ...\n}\n\nfn efficiency_objective(model: &amp;MyDecodedModel) -&gt; f32 {\n    // ... calculate efficiency ...\n}\n\n// Create weighted composite fitness function - this version computes a\n// weighted average of each function given to it\nlet composite_fitness = CompositeFitnessFn::new()\n    .add_weighted_fn(accuracy_objective, 0.6)      // 60% weight on accuracy\n    .add_weighted_fn(complexity_objective, 0.25)   // 25% weight on complexity\n    .add_weighted_fn(efficiency_objective, 0.15);  // 15% weight on efficiency\n\n// Create an equal weight composite fitness function with equal weights.\n// Meaning these are all essentially just added together to create a single objective.\nlet composite_fitness = CompositeFitnessFn::new()\n    .add_fitness_fn(accuracy_objective)\n    .add_fitness_fn(complexity_objective)\n    .add_fitness_fn(efficiency_objective);\n\n// Add it to the engine like any other fitness function\nlet engine = GeneticEngine::builder()\n    .codec(my_model_codec)\n    .fitness_fn(composite_fitness)\n    .build();\n</code></pre> <p>Key Features:</p> <ul> <li>Weighted combination: If using weighted, each objective has a weight that determines its importance</li> <li>Normalized scoring: If using weighted, scores are weighted and averaged</li> <li>Flexible objectives: Can combine any number of fitness functions</li> <li>Single objective: Results in a single score for selection</li> </ul>"},{"location":"source/fitness/#novelty-search","title":"Novelty Search","text":"<p>Novelty search is an advanced technique that rewards individuals for being behaviorally different from previously seen solutions, rather than just being \"better\" in terms of fitness. This helps avoid local optima and promotes exploration of the solution space. Below we can see a few members of the population generated by the python script here. You can see that each of these has an equal fitness score or 'novelty', but they produce vastly different outcomes. Each phenotype was graded on how novel their walk was between points A and B noted by the green and red dots repsectively.</p> <p>Novelty search works by:</p> <ol> <li>Behavioral Descriptors: Each individual is described by a behavioral descriptor (e.g., output patterns, feature values)</li> <li>Archive: Novel solutions are stored in an archive</li> <li>Distance Calculation: Novelty is measured as the average distance to the k-nearest neighbors in the archive</li> <li>Threshold: Solutions with novelty above a threshold are added to the archive</li> </ol> <p>You can implement your own behavioral descriptors by implementing the <code>Novelty</code> trait. </p>  Python Rust <pre><code>import radiate as rd\n\nclass MyModelBehaviorDescriptor:\n    def __init__(self, individual: List[float]):\n        self.individual = individual\n\n    def get_behavior_vector(self) -&gt; List[float]:\n        # some code that describes the behavior of a vector\n        ... \n\n# Define a behavioral descriptor\ndef description(self, individual: List[float]) -&gt; List[float]:\n    # Return behavioral characteristics \n    descriptor = MyModelBehaviorDesciptor(individual)\n    return descriptor.get_behavior_vector()\n\n# Create novelty search fitness function\nnovelty_fitness = rd.NoveltySearch(\n    behavior=description,\n    # can use any of the distance inputs. The engine will use this to \n    # determine how 'novel' an individual is compared to the other's in the \n    # archinve or population, ultimently resulting in the individuals fitness score.\n    distance=rd.CosineDistance() \n    k=10,           # Number of nearest neighbors to consider\n    threshold=0.1,   # Novelty threshold for archive addition\n    archive_size=1000, # defaults to 1000\n    batch=False # Whether to use batch evaluation - the default is false\n)\n\nengine = rd.GeneticEngine(\n    # whatever codec you specify - the decoded value of your codec will be fed \n    # into the `behavior` function of your NoveltySearch fitness_func\n    codec=rd.FloatCodec.vector(10, (0, 10)), \n    fitness_func=novelty_fitness,\n    # we always want to maximize novelty - however this is the default \n    # so its not necessary to define\n    objective='max' \n)\n</code></pre> <pre><code>use radiate::*;\n\n// Define a behavioral descriptor\nstruct MyModelBehaviorDescriptor;\n\n// ... rest of impl ...\n\nimpl Novelty&lt;MyModel&gt; for MyModelBehaviorDescriptor {\n    fn description(&amp;self, individual: &amp;MyModel) -&gt; Vec&lt;f32&gt; {\n        // Return behavioral characteristics (e.g., outputs on test cases)\n        individual.get_behavior_vector()\n    }\n}\n\n// Create novelty search fitness function\nlet novelty_fitness = NoveltySearch::new(MyModelBehaviorDescriptor)\n    .k(10)\n    .threshold(0.1)        \n    .with_archive_size(1000) // Optional: set archive size - default is 1000\n    .cosine_distance(); // Optional set the distance parameter used\n    // .euclidean_distance() // euclidean_distance is the default\n    // .hamming_distance()\n\n// Novelty is also implemented for any F where F: Fn(&amp;T) -&gt; Vec&lt;f32&gt;. Meaning, you can \n// just as easily feed a function to NoveltySearch as long as it takes a borrowed T (&amp;T) \n// and returns a Vec&lt;f32&gt;\nlet function_novelty_fitness = NoveltySearch::new(\n        |individual: &amp;MyModel| // ... return a Vec&lt;f32&gt; that describes MyModel ...\n    );\n\nlet engine = GeneticEngine::builder()\n    // The decoded genotype from your codec (my_model_codec in this case) will be fed\n    // into the `description` function from the Novelty trait impl \n    .codec(my_model_codec)\n    .maximizing()\n    .fitness_fn(novelty_fitness)\n    .build();\n</code></pre>"},{"location":"source/fitness/#best-practices","title":"Best Practices","text":""},{"location":"source/fitness/#choosing-the-right-fitness-function-type","title":"Choosing the Right Fitness Function Type","text":"<ol> <li>Simple Functions: Use for straightforward optimization problems</li> <li>Composite Functions: Use when you have multiple objectives that can be weighted</li> <li>Novelty Search: Use when you need to explore diverse solutions or avoid local optima and don't care much about the fitness score</li> </ol>"},{"location":"source/fitness/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Novelty Search: More computationally expensive due to distance calculations and archive management</li> <li>Composite Functions: Slight overhead from multiple function evaluations</li> <li>Archive Size: Larger archives in novelty search provide better diversity but use more memory</li> <li>Distance Calculations: Choose efficient distance metrics for novelty search</li> </ol>"},{"location":"source/fitness/#parameter-tuning","title":"Parameter Tuning","text":"<ol> <li>Novelty Threshold: Lower values add more solutions to archive, higher values are more selective</li> <li>K-Nearest Neighbors: Higher k provides more stable novelty scores but is more expensive</li> <li>Weights in Composite Functions: Balance objectives based on their relative importance</li> <li>Archive Size: Balance memory usage with diversity preservation</li> </ol>"},{"location":"source/fitness/#common-patterns","title":"Common Patterns","text":"<ol> <li>Fitness + Novelty: Combine traditional fitness with novelty for balanced exploration/exploitation</li> <li>Multi-Objective Composite: Use composite functions to handle multiple conflicting objectives</li> <li>Behavioral Descriptors: Use domain-specific behavioral characteristics for novelty search</li> </ol>"},{"location":"source/installation/","title":"Getting Started","text":""},{"location":"source/installation/#installing","title":"Installing","text":"<p>Installing Radiate is straightforward. Below are the instructions for each language - use whichever applicable package manager you prefer.</p>  Python Rust <pre><code>pip install radiate\n</code></pre> <pre><code>cargo add radiate -F gp\n\n# Or Cargo.toml\n[dependencies]\nradiate = { version = \"x\", features = [\"gp\", ...] }\n</code></pre>"},{"location":"source/installation/#importing","title":"Importing","text":"<p>To use Radiate, simply import it in your project as such:</p>  Python Rust <pre><code>import radiate as rd\n</code></pre> <pre><code>use radiate::*;\n</code></pre>"},{"location":"source/installation/#feature-flags","title":"Feature Flags","text":"<p>By installing the above, you will get the core library. However, Radiate has a few optional features that you can enable to extend its functionality.</p>"},{"location":"source/installation/#python","title":"Python","text":"<pre><code># requirements.txt\nradiate=0.0.10\n</code></pre> <p>Python's radiate package does not have any optional features - it is a single package that includes all functionality.</p>"},{"location":"source/installation/#rust","title":"Rust","text":"<pre><code>[dependencies]\n# Include the radiate crate with all optional features enabled.\nradiate = { version = \"1.2.20\", features = [\"gp\", \"serde\", \"rayon\", \"pgm\", \"smallvec\", \"ui\"] }\n</code></pre> <p>opt-in features include:</p> <ul> <li><code>gp</code>: Enables the genetic programming features, allowing you to work with tree and graph-based representations.</li> <li><code>serde</code>: Enables serialization and deserialization features, allowing you to save and load the Ecosystem state to/from disk. This is useful for long-running evolutionary processes or for resuming experiments.<ul> <li>Includes support for: Ecosystem, Population, Species, Phenotype, Genotype, all Chromosomes and their associated Genes, plus <code>gp</code>'s Graph and Tree structures. <li><code>rayon</code>: Enables parallel processing through the Rayon library. Radiate can run in parallel without this feature, but this is included due to its popularity and ease of use. <ul> <li>Note that the difference in performance between running with radiate's internal threadpool vs. Rayon is negligible for most use cases, so you can safely run without it if you prefer.</li> </ul> </li> <li><code>pgm</code>: This is an EXPERIMENTAL feature which enables probabilistic graphical models evolution. This is an add-on to the <code>gp</code> feature that allows <code>Op</code>s to hold tree structures, which enable nested graphical models.<ul> <li>This feature is still under active development and may change in future releases.</li> <li>This feature also automatically enables the <code>gp</code> feature.</li> </ul> </li> <li><code>smallvec</code>: This feature replaces standard <code>Vec&lt;T&gt;</code> usage in certain performance-critical areas with <code>SmallVec&lt;T&gt;</code>, which can reduce heap allocations and improve performance for small collections. This is particularly useful in genetic programming (Graphs) contexts where many small vectors are created and manipulated frequently.</li> <li><code>ui</code>: This feature enables a simple terminal command-line user interface (TUI) for monitoring and controlling evolutionary runs. It provides real-time feedback on the progress of the evolution, including a plethora of statistics and visualizations. Thanks to ratatui. Note that this is a completely opt-in feature and has no dependencies on the core library. This feature is still under active development and may change in future releases.</li>"},{"location":"source/objectives/","title":"Objectives","text":"<p>Objectives define the direction of optimization for your genetic algorithm. They determine whether the algorithm should minimize or maximize the fitness function, and support both single-objective and multi-objective optimization problems.</p> <p>The choice of objective is fundamental to the genetic algorithm's behavior, as it directly influences how individuals are ranked, selected, and evolved. Understanding how to properly configure objectives is essential for achieving optimal results in your optimization problems.</p> <p>The default objective is to maximize a single objective.</p> <p>This means that if you do not specify an objective, the algorithm will assume you want to maximize a single fitness function. If you want to minimize or use multi-objective optimization, you must explicitly configure it - see below.</p>"},{"location":"source/objectives/#overview","title":"Overview","text":"Objective Type Ex. Use Cases Complexity Performance Single Minimize Error/loss functions, cost optimization Low High Single Maximize Profit/revenue, performance metrics Low High Multi-Objective Conflicting objectives, trade-off analysis High Medium"},{"location":"source/objectives/#single-objective-optimization","title":"Single-Objective Optimization","text":"<p>Single-objective optimization focuses on optimizing one specific goal. This is by far the most common use case for genetic algorithms.  When using a single objective, you must return only a single value from your fitness function, which represents the fitness score for that individual.</p>"},{"location":"source/objectives/#minimization","title":"Minimization","text":"<p>Purpose: Find the minimum value of the fitness function</p> <p>The <code>minimizing()</code> method configures the genetic algorithm to find the minimum value of your fitness function. This is commonly used for error functions, cost optimization, and any scenario where you want to reduce a metric.</p>  Python Rust <pre><code>import radiate as rd\n\ncodec = rd.FloatCodec.vector(10, init_range=(0.0, 1.0))  # Example codec\n\nengine = rd.GeneticEngine(\n    codec=codec,\n    fitness_func=lambda x: sum(x),  # value to minimize\n    objective=\"min\" # Configure for minimization\n    # ... other parameters ...\n)\n\n# Or using builder pattern\nengine = rd.GeneticEngine(codec=codec, fitness_func=lambda x: sum(x))\nengine.minimizing()\n</code></pre> <pre><code>use radiate::*;\n\nlet engine = GeneticEngine::builder()\n    .codec(FloatCodec::vector(10, 0.0..1.0))  // Example codec\n    .minimizing() // Configure for minimization\n    .fitness_fn(|genotype| {\n        // Return a value to minimize\n        genotype.iter().sum::&lt;f32&gt;()\n    })\n    // ... other parameters ...\n    .build();\n</code></pre> <p>Common Applications:</p> <ul> <li>Error Functions: Minimize prediction error in machine learning</li> <li>Cost Optimization: Minimize production costs, travel distance</li> <li>Constraint Violations: Minimize penalty for constraint violations</li> <li>Loss Functions: Minimize training loss in neural networks</li> </ul>"},{"location":"source/objectives/#maximization","title":"Maximization","text":"<p>Purpose: Find the maximum value of the fitness function</p> <p>This is the default option for the <code>GeneticEngine</code>, so you don't really need to explicitly set this, but the functionality is provided for clarity and explicitness. The <code>maximizing()</code> method configures the genetic algorithm to find the maximum value of your fitness function. This is commonly used for profit optimization, performance metrics, and any scenario where you want to increase a metric.</p>  Python Rust <pre><code>import radiate as rd\n\ncodec = rd.FloatCodec.vector(10, (0.0, 1.0))  # Example codec\n\nengine = rd.GeneticEngine(\n    codec=codec,\n    fitness_func=lambda x: sum(x),  # return a value to maximize\n    objective=\"max\"\n    # ... other parameters ...\n)\n\n# Or using builder pattern\nengine = rd.GeneticEngine(codec=codec, fitness_func=lambda x: sum(x))\nengine.maximizing()\n</code></pre> <pre><code>use radiate::*;\n\nlet engine = GeneticEngine::builder()\n    .codec(FloatCodec::vector(10, 0.0..1.0))  // Example codec\n    .maximizing()  // Configure for maximization\n    .fitness_fn(|genotype| {\n        // Return a value to maximize\n        genotype.iter().sum::&lt;f32&gt;()\n    })\n    // ... other parameters ...\n    .build();\n</code></pre> <p>Common Applications:</p> <ul> <li>Profit Optimization: Maximize revenue, return on investment</li> <li>Performance Metrics: Maximize accuracy, precision, recall</li> <li>Quality Scores: Maximize product quality, user satisfaction</li> <li>Resource Utilization: Maximize efficiency, throughput</li> </ul>"},{"location":"source/objectives/#multi-objective-optimization","title":"Multi-Objective Optimization","text":"<p>Multi-objective optimization allows you to optimize multiple conflicting objectives simultaneously. Instead of finding a single \"best\" solution, you find a set of Pareto-optimal solutions that represent different trade-offs between objectives. You'll notice in the examples below that the fitness function returns a list of values, each representing a different objective. The number of objectives should match the number of directions specified.</p> <p>Purpose: Optimize multiple conflicting objectives simultaneously</p>"},{"location":"source/objectives/#setting-up-mo-problems","title":"Setting Up MO Problems","text":"<p>Use <code>multi_objective()</code> with a list of optimization directions to configure multi-objective optimization. To control the size of the Pareto front, use <code>front_range()</code> to specify the minimum and maximum number of solutions to maintain as seen below:</p>  Python Rust <pre><code>import radiate as rd\n\ncodec = rd.FloatCodec.vector(10, (0.0, 1.0))  # Example codec\n\nengine = rd.GeneticEngine(\n    codec=codec,\n    fitness_func=lambda x: [obj1_fitness_func(x), obj2_fitness_func(x)],  # Return list of objectives\n    objective=[\"min\", \"max\"]  # Minimize obj1, maximize obj2\n    front_range=(800, 900)  # Pareto front size range\n    # ... other parameters ...\n)\n\n# Or using builder pattern\nengine = rd.GeneticEngine(codec=codec, fitness_func=lambda x: [obj1_fitness_func(x), obj2_fitness_func(x)])\nengine.multi_objective([\"min\", \"max\"], front_range=(800, 900))\n</code></pre> <pre><code>use radiate::*;\n\nlet engine = GeneticEngine::builder()\n    .codec(FloatCodec::vector(10, 0.0..1.0))  // Example codec\n    .multi_objective(vec![Optimize::Minimize, Optimize::Maximize])\n    .front_size(800..900)  // Pareto front size range\n    .fitness_fn(|genotype| {\n        // Return a vector of fitness values\n        vec![\n            objective1(genotype),  // Minimize this\n            objective2(genotype),  // Maximize this\n        ]\n    })\n    // ... other parameters ...\n    .build();\n</code></pre>"},{"location":"source/objectives/#pareto-front-management","title":"Pareto Front Management","text":"<p>The <code>front_size()</code> parameter controls the size of the Pareto front. When the pareto front is full (reaches the upper bound), the algorithm will truncate down to the lower bound by removing solutions based on Pareto dominance and crowding distance.</p>"},{"location":"source/objectives/#mo-selectors","title":"MO Selectors","text":"<p>Because of the complexity of multi-objective problems, specialized selectors are available which are optimized for handling Pareto dominance and diversity:</p> <ul> <li><code>NSGA2Selector</code>: Implements the NSGA-II algorithm for non-dominated sorting and crowding distance</li> <li><code>TournamentNSGA2Selector</code>: Uses tournament selection with Pareto dominance</li> </ul> <p>Although, any selector can be used, these are optimized for multi-objective problems. The other selectors will work by computing a 'weight' based off of the pareto dominance and crowding distance, but they are not backed by any specific multi-objective algorithm.</p>  Python Rust <pre><code>import radiate as rd\n\nengine = rd.GeneticEngine(\n    codec=rd.FloatCodec.vector(10, (0.0, 1.0)),  # Example codec\n    fitness_func=lambda x: [obj1(x), obj2(x)],\n    front_range=(800, 900),  # Pareto front size range\n    objective=[\"min\", \"max\"]\n)\n\nengine.survivor_selector(rd.NSGA2Selector())                # NSGA-II for Pareto ranking\nengine.offspring_selector(rd.TournamentNSGA2Selector(k=3))  # Tournament selection with Pareto dominance\n</code></pre> <pre><code>use radiate::*;\n\nlet engine = GeneticEngine::builder()\n    .codec(FloatCodec::vector(10, 0.0..1.0))  // Example codec\n    .multi_objective(vec![Optimize::Minimize, Optimize::Maximize])\n    .survivor_selector(NSGA2Selector::new())                // NSGA-II for Pareto ranking\n    .offspring_selector(TournamentNSGA2Selector::new(3))    // Tournament selection with Pareto dominance\n    .front_size(800..900)  // Pareto front size range\n    .fitness_fn(|genotype| {\n        vec![\n            objective1(genotype),  // Minimize this\n            objective2(genotype),  // Maximize this\n        ]\n    })\n    .build();\n</code></pre>"},{"location":"source/objectives/#best-practices","title":"Best Practices","text":""},{"location":"source/objectives/#choosing-objectives","title":"Choosing Objectives","text":"<ol> <li>Single-objective: Use when you have a clear, single goal</li> <li>Multi-objective: Use when objectives conflict or you need trade-off analysis</li> <li>Objective count: Keep multi-objective channels to a manageable number</li> </ol>"},{"location":"source/objectives/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Single-objective: Generally faster and more focused</li> <li>Multi-objective: More computationally intensive</li> <li>Front size: Larger fronts provide better coverage but increase memory usage and computation time</li> <li>Objective count: More objectives increase complexity exponentially</li> </ol>"},{"location":"source/objectives/#troubleshooting","title":"Troubleshooting","text":""},{"location":"source/objectives/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Problem: Algorithm converges to poor solutions</p> <ul> <li>Solution: Check objective direction (minimize vs maximize)</li> </ul> </li> <li> <p>Problem: Multi-objective front is too small</p> <ul> <li>Solution: Increase front size range or adjust selection pressure</li> </ul> </li> </ol>"},{"location":"source/releases/","title":"Release Notes","text":""},{"location":"source/releases/#v1220-py-0010","title":"v1.2.20 - py 0.0.10","text":"<ul> <li>2025-12-15</li> <li>Release</li> </ul> <p>Adding radiate-ui crate, bug fixes, &amp; speed improvements. </p> <p>I split up some functionality into a new crate radiate-utils and have added a new feature radiate-ui for a tui user interface through ratitui. Some small bug fixes, code simplifications, and some nice little speed improvements. </p> <p>Full Changelog</p>"},{"location":"source/releases/#v1219-py-009","title":"v1.2.19 - py 0.0.9","text":"<ul> <li>2025-11-11</li> <li>Release</li> </ul> <p>Adding support for experimental PGM or Probabilistic graphical models through the GP feature (crate).</p> <p>Major cleanup or unused code and massive graph performance improvements through the use of smallvec as connections instead of BTreeSets. </p> <p>Improving eventing system through cleaner code and removing redundant events.</p> <p>Introducing radiate-error (RadiateError) into the core crates ad requiring its usage in certain traits (Problem mainly). We also use this error type in py-radiate and allow it to bubble up into python's type system too. </p> <p>Brining metrics to the forefront in python. </p> <p>Full Changelog</p>"},{"location":"source/releases/#v1218-py-008","title":"v1.2.18 - py 0.0.8","text":"<ul> <li>2025-09-27</li> <li>Release</li> </ul> <p>Fixing subtle bug in recurrent graphs where a random seed wasn't being respected, leading to non-deterministic behavior in some cases. This fix ensures that all random operations within recurrent graphs are consistent and reproducible when a seed is provided. </p> <p>Added three new types of graphs:</p> <ul> <li>LSTM (Long Short-Term Memory) Graphs: These are a type of recurrent neural network (RNN) that can learn long-term dependencies.</li> <li>GRU (Gated Recurrent Unit) Graphs: Similar to LSTMs, GRUs are a type of RNN that are simpler and often more efficient.</li> <li>Mesh Graphs: Graphs structured in a mesh topology.</li> </ul>"},{"location":"source/releases/#v1217-py-007","title":"v1.2.17 - py 0.0.7","text":"<ul> <li>2025-09-04</li> <li>Release</li> </ul> <p>In response to github issue #23.</p> <p>Ensuring that FloatGenes/IntGene's respect their bounds during mutation and crossover. This was a bug where mutated or crossovered genes could exceed their defined bounds, which could lead to invalid individuals in the population. This fix ensures that all FloatGenes/IntGene's remain within their specified bounds after any genetic operation. Also some optimizations and code cleanup for py-radiate. Large additions to tests. <p>Also adding new mutator: <code>JitterMutator</code> for FloatGenes. This mutator adds a small random value (jitter) to each gene, controlled by a <code>magnitude</code> parameter.</p>"},{"location":"source/releases/#v1216","title":"v1.2.16","text":"<ul> <li>2025-08-19</li> <li>Release</li> </ul> <p>In response to github issue #22.</p> <p>Adding support for batch fitness functions and batch engine problems through a new trait (BatchFitnessFn). Some small cleanup on other fitness functions and some chromosome operators.</p>"},{"location":"source/releases/#v1215-py-006","title":"v1.2.15 - py 0.0.6","text":"<ul> <li>2025-08-10</li> <li>Release</li> </ul> <p>Adding Novelty Search to python and refactoring engine building across the rust/python bridge. Improving python's speed. Adding type checking to python and upgrading python package to &gt;= python 3.12 to support new python generics. Improving docs to reference new functionality.</p> <p>New alters:</p> <ul> <li>EdgeRecombinationCrossover for PermutationGenes </li> <li>PolynomialMutator for chromosomes with FloatGenes</li> </ul> <p>Added code path in alters for dynamic mutation/crossover rates. This is in early dev, but an be seen in PolynomialMutator.</p>"},{"location":"source/releases/#v1214-py-004","title":"v1.2.14 - py 0.0.4","text":"<ul> <li>2025-07-05</li> <li>Release</li> </ul> <p>Added support for novelty search, fitness-based novelty, and combined novelty and fitness search. Improved documentation and examples. Improved traits for <code>Engine</code> and introduced one for <code>FitnessFn</code>. Bug fixes for pareto fronts and engine iterators.</p>"},{"location":"source/alters/","title":"Alterers","text":"<p>Alterers are genetic operators that modify the genetic material of individuals in a <code>population</code>. In Radiate, there are two main types of alterers:</p> <ol> <li>Mutators: Operators that modify individual genes or chromosomes</li> <li>Crossovers: Operators that combine genetic material from two parents to create offspring</li> </ol> <p>These operators modify the <code>population</code> and are essential for the genetic algorithm to explore the search space effectively. As such, the choice of <code>alterer</code> can have a significant impact on the performance of the genetic algorithm, so it is important to choose an <code>alterer</code> that is well-suited to the problem being solved.</p>"},{"location":"source/alters/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Rate Selection:</p> <ul> <li>Start with conservative rates (0.01 for mutation, 0.5-0.8 for crossover)</li> <li>Adjust based on problem characteristics</li> <li>Higher rates increase exploration but may disrupt good solutions</li> </ul> </li> <li> <p>Choosing the Right Alterer:</p> <ul> <li>For continuous problems: Use Gaussian or Arithmetic mutators with Blend/Intermediate crossover</li> <li>For permutation problems: Use Swap/Scramble mutators with PMX or Shuffle crossover</li> <li>For binary problems: Use Uniform mutator with Multi-point or Uniform crossover</li> </ul> </li> <li> <p>Combining Alterers:</p> <ul> <li>It's often beneficial to use multiple alterers</li> <li>Example: Combine a local search mutator (Gaussian) with a global search crossover (Multi-point)</li> <li>Monitor population diversity to ensure proper balance</li> </ul> </li> <li> <p>Parameter Tuning:</p> <ul> <li>Start with default parameters</li> <li>Adjust based on problem size and complexity</li> <li>Use smaller rates for larger problems</li> </ul> </li> </ol>"},{"location":"source/alters/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li> <p>Too High Mutation Rates:</p> <ul> <li>Can lead to random search behavior</li> <li>May destroy good solutions before they can be exploited</li> <li>Solution: Start with low rates (0.01-0.1) and adjust based on results</li> </ul> </li> <li> <p>Inappropriate Crossover Selection:</p> <ul> <li>Using permutation crossovers for continuous problems</li> <li>Using continuous crossovers for permutation problems</li> <li>Solution: Match the crossover type to your problem domain</li> </ul> </li> <li> <p>Ignoring Problem Constraints:</p> <ul> <li>Some alterers may produce invalid solutions</li> <li>Solution: Use appropriate alterers or implement repair mechanisms</li> </ul> </li> <li> <p>Poor Parameter Tuning:</p> <ul> <li>Using the same parameters for all problems</li> <li>Solution: Experiment with different parameters and monitor performance</li> </ul> </li> </ol>"},{"location":"source/alters/crossovers/","title":"Crossovers","text":"<p>Crossovers combine genetic material from two parents to create offspring, allowing good traits to be combined and propagated through the population.</p>"},{"location":"source/alters/crossovers/#blend","title":"Blend","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Crossover rate (0.0 to 1.0)</li> <li><code>alpha</code>: f32 - Blending factor (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Creates offspring by blending parent genes using a weighted average</li> <li>Best for: Continuous optimization problems</li> <li>Example: Useful when you want to explore the space between parent solutions</li> <li>Compatible with: <code>FloatGene</code>, <code>IntGene&lt;I&gt;</code></li> </ul> <p>The <code>BlendCrossover</code> is a crossover operator designed for <code>ArithmeticGene</code>s. It introduces variability by blending the <code>gene</code> controlled by the <code>alpha</code> parameter. This approach allows for smooth transitions between <code>gene</code> values, promoting exploration of the search space. Its functionality is similar to the <code>IntermediateCrossover</code>, but it uses a different formula to calculate the new <code>gene</code> value. Its defined as:</p> \\[ \\text{allele}_{\\text{child}} = \\text{allele}_{\\text{parent1}} - \\alpha \\cdot (\\text{allele}_{\\text{parent2}} - \\text{allele}_{\\text{parent1}}) \\]  Python Rust <pre><code>import radiate as rd\n\ncrossover = rd.BlendCrossover(rate=0.1, alpha=0.5)\n</code></pre> <pre><code>use radiate::*;\n\nlet crossover = BlendCrossover::new(0.1, 0.5);\n</code></pre>"},{"location":"source/alters/crossovers/#intermediate","title":"Intermediate","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Crossover rate (0.0 to 1.0)</li> <li><code>alpha</code>: f32 - Blending factor (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Similar to blend crossover but uses a different blending formula</li> <li>Best for: Real-valued optimization problems</li> <li>Example: Good for fine-tuning solutions in continuous spaces</li> <li>Compatible with: <code>FloatGene</code></li> </ul> <p>The <code>IntermediateCrossover</code> operator is a crossover mechanism designed for <code>ArithmeticGene</code>s.  It combines the corresponding <code>genes</code> of two parent chromosomes by replacing a gene in one chromosome with a value that lies between the two parent <code>genes</code>. The new gene is calculated as the weighted average of the two parent <code>genes</code>, where the weight is determined by the <code>alpha</code> parameter.</p> <ol> <li>Input:<ul> <li>Two parent chromosomes (Parent 1 and Parent 2) composed of real-valued genes.</li> <li>A crossover <code>rate</code>, determining the probability of applying the operation for each gene.</li> <li>An interpolation parameter (<code>alpha</code>), which controls the weight given to each parent\u2019s gene during crossover.</li> </ul> </li> <li> <p>Weighted Interpolation:</p> <ul> <li>For each gene position in the parents:</li> <li>Generate a random value between 0 and 1.</li> <li>If the random value is less than the rate, compute a new allele as a weighted combination of the parent\u2019s alleles:</li> </ul> \\[ \\text{allele}_{\\text{child}} = \\alpha \\cdot \\text{allele}_{\\text{parent1}} + (1 - \\alpha) \\cdot \\text{allele}_{\\text{parent2}} \\] <ul> <li>Here, \\({alpha}\\) is randomly sampled from the range [0, \\({self.alpha}\\)].</li> </ul> </li> <li> <p>Modify Genes:</p> <ul> <li>Replace the gene in Parent 1 with the newly calculated gene value. Parent 2 remains unmodified.</li> </ul> </li> </ol>  Python Rust <pre><code>import radiate as rd\n\ncrossover = rd.IntermediateCrossover(rate=0.1, alpha=0.5)\n</code></pre> <pre><code>use radiate::*;\n\nlet crossover = IntermediateCrossover::new(0.1, 0.5);\n</code></pre>"},{"location":"source/alters/crossovers/#mean","title":"Mean","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Crossover rate (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Creates offspring by taking the mean of parent genes</li> <li>Best for: Problems where averaging parent values is meaningful</li> <li>Example: Useful for numerical optimization where the average of good solutions might be better</li> <li>Compatible with: <code>FloatGene</code>, <code>IntGene&lt;I&gt;</code></li> </ul> <p>The <code>MeanCrossover</code> operator is a crossover mechanism designed  for <code>ArithmeticGene</code>s. It combines the corresponding <code>genes</code> of two parent chromosomes by  replacing a gene in one chromosome with the mean (average) of the two <code>genes</code>. This approach  is useful when <code>genes</code> represent numeric values such as weights or coordinates,  as it promotes a balanced combination of parent traits.</p>  Python Rust <pre><code>import radiate as rd\n\ncrossover = rd.MeanCrossover(rate=0.1)\n</code></pre> <pre><code>use radiate::*;\n\nlet crossover = MeanCrossover::new(0.1);\n</code></pre>"},{"location":"source/alters/crossovers/#multi-point","title":"Multi-Point","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Crossover rate (0.0 to 1.0)</li> <li><code>num_points</code>: int - Number of crossover points (typically 1 or 2)</li> </ul> <ul> <li>Purpose: Swaps segments between parents at multiple points</li> <li>Best for: General-purpose crossover for most problems</li> <li>Example: Classic genetic algorithm crossover, good for most applications</li> <li>Compatible with: <code>FloatGene</code>, <code>IntGene&lt;I&gt;</code>, <code>BitGene</code>, <code>CharGene</code>, <code>PermutationGene&lt;A&gt;</code></li> </ul> <p>The <code>MultiPointCrossover</code> is a crossover operator that combines two parent individuals by selecting multiple crossover points and swapping the genetic material between the parents at those points. This is a  classic crossover operator.</p>  Python Rust <pre><code>import radiate as rd\n\ncrossover = rd.MultiPointCrossover(rate=0.1, num_points=2)\n</code></pre> <pre><code>use radiate::*;\n\nlet crossover = MultiPointCrossover::new(0.1, 2);\n</code></pre>"},{"location":"source/alters/crossovers/#partially-mapped-pmx","title":"Partially Mapped (PMX)","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Crossover rate (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Specialized crossover for permutation problems</li> <li>Best for: Permutation problems (TSP, scheduling)</li> <li>Example: Ideal for problems where gene order matters and no duplicates are allowed</li> <li>Compatible with: <code>PermutationGene&lt;A&gt;</code></li> </ul> <p>The <code>PMXCrossover</code> is a genetic algorithm crossover technique used for problems where solutions are represented as permutations. It is widely used in combinatorial optimization problems, such as the Traveling Salesman Problem (TSP), where the order of elements in a solution is significant.</p> <ol> <li>Two random crossover points are selected, dividing the parents into three segments: left, middle, and right.<ul> <li>The middle segment defines the \u201cmapping region.\u201d</li> </ul> </li> <li>Mapping Region:<ul> <li>The elements between the crossover points in Parent 1 and Parent 2 are exchanged to create mappings.</li> <li>These mappings define how elements in the offspring are reordered.</li> </ul> </li> <li>Child Construction:<ul> <li>The middle segment of one parent is directly copied into the child.</li> <li>For the remaining positions, the mapping ensures that no duplicate elements are introduced:</li> <li>If an element is already in the middle segment, its mapped counterpart is used.</li> <li>This process continues recursively until all positions are filled.</li> </ul> </li> </ol>  Python Rust <pre><code>import radiate as rd\n\ncrossover = rd.PartiallyMappedCrossover(rate=0.1)\n</code></pre> <pre><code>use radiate::*;\n\nlet crossover = PMXCrossover::new(0.1);\n</code></pre>"},{"location":"source/alters/crossovers/#edge-recombination","title":"Edge Recombination","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Crossover rate (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Combines edges from both parents</li> <li>Best for: Permutation problems (TSP, scheduling)</li> <li>Example: Useful for problems where the relationship between genes is important</li> <li>Compatible with: <code>PermutationGene&lt;A&gt;</code></li> </ul> <p>The <code>EdgeRecombinationCrossover</code> is a specialized crossover operator for permutation problems. It focuses on preserving the connectivity between genes by combining edges from both parents.</p> <ol> <li>Edge List Creation:<ul> <li>For each parent, create a list of edges representing the connections between genes.</li> </ul> </li> <li>Edge Selection:<ul> <li>Randomly select edges from both parents to create a new offspring.</li> <li>This selection process ensures that the offspring inherits important connections from both parents.</li> </ul> </li> <li>Child Construction:<ul> <li>The selected edges are used to construct the offspring's gene sequence.</li> <li>This process helps maintain the overall structure and relationships present in the parent solutions.</li> </ul> </li> </ol> <p>Example: If Parent 1 has edges (A-B, B-C) and Parent 2 has edges (B-C, C-D), the offspring might inherit edges (A-B, C-D).</p>  Python Rust <pre><code>import radiate as rd\n\ncrossover = rd.EdgeRecombinationCrossover(rate=0.1)\n</code></pre> <pre><code>use radiate::*;\n\nlet crossover = EdgeRecombinationCrossover::new(0.1);\n</code></pre>"},{"location":"source/alters/crossovers/#shuffle","title":"Shuffle","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Crossover rate (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Shuffles genes before performing crossover</li> <li>Best for: Problems where gene position is important</li> <li>Example: Useful for problems where you want to maintain gene independence while exploring new combinations</li> <li>Compatible with: <code>FloatGene</code>, <code>IntGene&lt;I&gt;</code>, <code>BitGene</code>, <code>CharGene</code>, <code>PermutationGene&lt;A&gt;</code></li> </ul> <p>The <code>ShuffleCrossover</code> is a crossover operator used in genetic algorithms,  particularly when working with permutations or chromosomes where order matters.  It works by shuffling the order in which genes are exchanged between two parent chromosomes  to introduce randomness while preserving valid gene configurations.</p> <ol> <li>Determine Gene Indices:<ul> <li>Generate a list of indices corresponding to the positions in the chromosomes.</li> <li>Shuffle these indices to randomize the order in which genes will be swapped.</li> </ul> </li> <li>Swap Genes Alternately:<ul> <li>Iterate over the shuffled indices.</li> <li>For even indices, copy the gene from Parent 2 into the corresponding position in Child 1, and vice versa for odd indices.</li> </ul> </li> <li>Result:<ul> <li>Two offspring chromosomes are produced with genes shuffled and swapped in random positions.</li> </ul> </li> </ol>  Python Rust <pre><code>import radiate as rd\n\ncrossover = rd.ShuffleCrossover(rate=0.1)\n</code></pre> <pre><code>use radiate::*;\n\nlet crossover = ShuffleCrossover::new(0.1);\n</code></pre>"},{"location":"source/alters/crossovers/#simulated-binary","title":"Simulated Binary","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Crossover rate (0.0 to 1.0)</li> <li><code>contiguity</code>: f32 - Contiguity factor (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Simulates binary crossover for real-valued genes</li> <li>Best for: Real-valued optimization problems</li> <li>Example: Good for problems where you want to maintain diversity while exploring the space</li> <li>Compatible with: <code>FloatGene</code></li> </ul> <p>The <code>SimulatedBinaryCrossover</code> is a crossover operator designed for <code>FloatGene</code>s. It simulates binary crossover by creating offspring that are a linear combination of the parents, controlled by a contiguity factor. Effectively, it allows for a smooth transition between parent values while maintaining the overall structure of the <code>genes</code> by smampling from a uniform distribution between the two parents.</p>  Python Rust <pre><code>import radiate as rd\n\ncrossover = rd.SimulatedBinaryCrossover(rate=0.1, contiguity=0.5)\n</code></pre> <pre><code>use radiate::*;\n\nlet crossover = SimulatedBinaryCrossover::new(0.1, 0.5);\n</code></pre>"},{"location":"source/alters/crossovers/#uniform","title":"Uniform","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Crossover rate (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Randomly selects genes from either parent</li> <li>Best for: Problems where gene independence is high</li> <li>Example: Useful when genes have little interaction with each other</li> <li>Compatible with: <code>FloatGene</code>, <code>IntGene&lt;I&gt;</code>, <code>BitGene</code>, <code>CharGene</code>, <code>PermutationGene&lt;A&gt;</code></li> </ul> <p>The <code>UniformCrossover</code> is a crossover operator creates new individuals by selecting <code>genes</code> from the parents with equal probability and swapping them between the parents. This is a simple crossover operator that can be effective in a wide range of problems.</p>  Python Rust <pre><code>import radiate as rd\n\ncrossover = rd.UniformCrossover(rate=0.1)\n</code></pre> <pre><code>use radiate::*;\n\nlet crossover = UniformCrossover::new(0.1);\n</code></pre>"},{"location":"source/alters/example/","title":"Example","text":"<p>Continuing with our example from the previous two sections - evolving a simple function: finding the best values for <code>y = ax + b</code> where we want to find optimal values for <code>a</code> and <code>b</code>. We'll use the same <code>codec</code> and <code>fitness_function</code> as before, but this time we'll add alterers to the <code>GeneticEngine</code> to evolve the parameters.</p>  Python Rust <pre><code>import radiate as rd\n\n# Define a fitness function that uses the decoded values\ndef fitness_function(individual: list[float]) -&gt; float:    \n    # Calculate how well these parameters fit your data\n    a = individual[0]\n    b = individual[1]\n    return calculate_error(a, b)  # Your error calculation here\n\n# Create a codec for two parameters (a and b)\ncodec = rd.FloatCodec.vector(\n    length=2,                   # We need two parameters: a and b\n    init_range=(-1.0, 1.0),    # Start with values between -1 and 1\n    bounds=(-10.0, 10.0)       # Allow evolution to modify the values between -10 and 10\n)\n\n# Use Boltzmann selection for offspring - individuals which\n# will be used to create new individuals through mutation and crossover\noffspring_selector = rd.BoltzmannSelector(temp=4)\n\n# Use tournament selection for survivors - individuals which will \n# be passed down unchanged to the next generation\nsurvivor_selector = rd.TournamentSelector(k=3)\n\n# Define the alterers - these will be applied to the selected offspring\n# to create new individuals. They will be applied in the order they are defined.\nalters = [\n    rd.GaussianMutator(rate=0.1),\n    rd.BlendCrossover(rate=0.8, alpha=0.5)\n]\n\n# Create the evolution engine\nengine = rd.GeneticEngine(\n    codec=codec,\n    fitness_func=fitness_function,\n    offspring_selector=offspring_selector,\n    survivor_selector=survivor_selector,\n    alters=alters # Add the alterers to the engine\n    # ... other parameters ...\n)\n\n# Run the engine\nresult = engine.run([rd.ScoreLimit(0.01), rd.GenerationsLimit(1000)])\n</code></pre> <pre><code>use radiate::*;\n\n// Define a fitness function that uses the decoded values\nfn fitness_fn(individual: Vec&lt;f32&gt;) -&gt; f32 {\n    let a = individual[0];\n    let b = individual[1];\n    calculate_error(a, b)  // Your error calculation here\n}\n\n// This will produce a Genotype&lt;FloatChromosome&gt; with 1 FloatChromosome which\n// holds 2 FloatGenes (a and b), each with a value between -1.0 and 1.0 and a bound between -10.0 and 10.0\nlet codec = FloatCodec::vector(2, -1.0..1.0).with_bounds(-10.0..10.0);\n\n// Use Boltzmann selection for offspring - individuals which\n// will be used to create new individuals through mutation and crossover\nlet offspring_selector = BoltzmannSelector::new(4.0);\n\n// Use tournament selection for survivors - individuals which will\n// be passed down unchanged to the next generation\nlet survivor_selector = TournamentSelector::new(3);\n\n// There are a few different ways we can add alters to the engine in rust. Assuming you \n// use the same alters for each method below, the resulting engine will be the same.\n// Choose the one that you prefer, but keep in mind that the alters \n// will be applied in the order they are defined.\n\n// ---------------------------------------\n// 1.) Using the \"alters!\" macro - this is the most flexible way to add multiple mutators and crossovers\n// ---------------------------------------\nlet alters = alters![\n    GaussianMutator::new(0.1),\n    BlendCrossover::new(0.8, 0.5)\n];\n\nlet mut engine = GeneticEngine::builder()\n    .codec(codec)\n    .offspring_selector(offspring_selector)\n    .survivor_selector(survivor_selector)\n    .fitness_fn(fitness_fn)\n    .alterers(alters) // Add the alterers to the engine\n    // ... other parameters ...\n    .build();\n\n// ---------------------------------------\n// 2.) Using the \"mutators\" and \"crossovers\" methods to apply a single mutator and crossover\n// ---------------------------------------\nlet mutator = UniformMutator::new(0.1);\nlet crossover = MultiPointCrossover::new(0.8, 2);\n\nlet mut engine = GeneticEngine::builder()\n    .codec(codec)\n    .offspring_selector(offspring_selector)\n    .survivor_selector(survivor_selector)\n    .mutator(mutator)\n    .crossover(crossover)\n    .fitness_fn(fitness_fn)\n    // ... other parameters ...\n    .build();\n\n// ---------------------------------------\n// 3.) Using the \"mutators\" and \"crossovers\" methods with vectors\n// ---------------------------------------\nlet mutators: Vec&lt;Box&lt;dyn Mutator&gt;&gt; = vec![\n    Box::new(GaussianMutator::new(0.1)),\n    Box::new(UniformMutator::new(0.05)),\n];\n\nlet crossovers: Vec&lt;Box&lt;dyn Crossover&gt;&gt; = vec![\n    Box::new(MultiPointCrossover::new(0.8, 2)),\n    Box::new(UniformCrossover::new(0.75)),\n];\n\nlet mut engine = GeneticEngine::builder()\n    .codec(codec)\n    .offspring_selector(offspring_selector)\n    .survivor_selector(survivor_selector)\n    .mutators(mutators)\n    .crossovers(crossovers)\n    .fitness_fn(fitness_fn)\n    // ... other parameters ...\n    .build();\n\n// Run the engine\nlet result = engine.run(|generation| {\n    generation.index() &gt;= 1000 || generation.score().as_f32() &lt;= 0.01\n});\n</code></pre>"},{"location":"source/alters/mutators/","title":"Mutators","text":"<p>Mutators introduce (usually small) random changes to individual genes or chromosomes, helping maintain diversity in the population and enabling exploration of the search space.</p>"},{"location":"source/alters/mutators/#uniform","title":"Uniform","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Mutation rate (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Randomly changes genes to new random values</li> <li>Best for: General-purpose mutation when you want simple random changes</li> <li>Example: Binary or discrete genes where you want to flip values randomly</li> <li>Compatible with: <code>BitGene</code>, <code>CharGene</code>, <code>FloatGene</code>, <code>IntGene&lt;I&gt;</code>, <code>PermutationGene&lt;A&gt;</code></li> </ul> <p>The most basic mutation operator. It randomly replaces a gene with a new instance of the gene type.</p>  Python Rust <pre><code>import radiate as rd\n\nmutator = rd.UniformMutator(rate=0.1)\nmutator = rd.UniformMutator(rate=rd.Rate.fixed(0.1))\n</code></pre> <pre><code>use radiate::*;\n\nlet mutator = UniformMutator::new(0.1);\nlet mutator = UniformMutator::from(Rate::fixed(0.1));\n</code></pre>"},{"location":"source/alters/mutators/#gaussian","title":"Gaussian","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Mutation rate (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Adds Gaussian (normal) noise to gene values</li> <li>Best for: Continuous values where you want small, normally distributed changes</li> <li>Example: Perfect for fine-tuning real-valued parameters in optimization problems</li> <li>Compatible with: <code>FloatGene</code></li> </ul> <p>The <code>GaussianMutator</code> operator is a mutation mechanism designed for <code>ArithmeticGene</code>s. It introduces random noise to the gene values by adding a sample from a Gaussian distribution with a specified standard deviation. This mutation operator produces small, incremental changes centered around the current gene value.</p>  Python Rust <pre><code>import radiate as rd\n\nmutator = rd.GaussianMutator(rate=0.1)\n</code></pre> <pre><code>use radiate::*;\n\nlet mutator = GaussianMutator::new(0.1);\n</code></pre>"},{"location":"source/alters/mutators/#arithmetic","title":"Arithmetic","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Mutation rate (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Performs arithmetic operations (add, subtract, multiply, divide) on <code>genes</code></li> <li>Best for: Genes that support arithmetic operations</li> <li>Example: Useful for numerical optimization where you want to explore the space through arithmetic operations</li> <li>Compatible with: <code>FloatGene</code>, <code>IntGene&lt;I&gt;</code></li> </ul> <p>The <code>ArithmeticMutator</code> introduces diversity into genetic algorithms by mutating numerically based <code>genes</code> through basic arithmetic operations. It is designed to work on <code>genes</code> that support addition, subtraction, multiplication, and division. Once the values have gone through their arithmatic operation, the result is clamped by the <code>gene</code>'s bounds to ensure it remains valid.</p> <ol> <li>Choose a random arithmetic operation: addition, subtraction, multiplication, or division.</li> <li>Apply the operation to the <code>gene</code> value using a randomly generated value of the same <code>gene</code> type.</li> <li>Replace the original <code>gene</code> with the result of the operation.</li> </ol>  Python Rust <pre><code>import radiate as rd\n\nmutator = rd.ArithmeticMutator(rate=0.1)\n</code></pre> <pre><code>use radiate::*;\n\nlet mutator = ArithmeticMutator::new(0.1);\n</code></pre>"},{"location":"source/alters/mutators/#swap","title":"Swap","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Mutation rate (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Swaps positions of two <code>genes</code> within a <code>chromosome</code></li> <li>Best for: Permutation problems (like TSP) or ordered sequences</li> <li>Example: Ideal for problems where gene order matters, like scheduling or routing</li> <li>Compatible with: <code>BitGene</code>, <code>CharGene</code>, <code>FloatGene</code>, <code>IntGene&lt;I&gt;</code>, <code>PermutationGene&lt;A&gt;</code></li> </ul> <p>The <code>SwapMutator</code> is a mutation operator designed for genetic algorithms to swap the positions of two <code>Gene</code>s in a <code>Chromosome</code>. This mutator swaps two <code>Gene</code>s at randomly selected indices, introducing variability while maintaining the <code>chromosome</code>s structural integrity. It is particularly suited for permutation-based problems.</p>  Python Rust <pre><code>import radiate as rd\n\nmutator = rd.SwapMutator(rate=0.1)\n</code></pre> <pre><code>use radiate::*;\n\nlet mutator = SwapMutator::new(0.1);\n</code></pre>"},{"location":"source/alters/mutators/#scramble","title":"Scramble","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Mutation rate (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Randomly reorders a segment of <code>genes</code></li> <li>Best for: Breaking up local optima in ordered sequences</li> <li>Example: Useful for permutation problems where you want to explore different orderings</li> <li>Compatible with: <code>BitGene</code>, <code>CharGene</code>, <code>FloatGene</code>, <code>IntGene&lt;I&gt;</code>, <code>PermutationGene&lt;A&gt;</code></li> </ul> <p>The <code>ScrambleMutator</code> randomly reorders a segment of <code>genes</code> within a <code>chromosome</code>. </p>  Python Rust <pre><code>import radiate as rd\n\nmutator = rd.ScrambleMutator(rate=0.1)\n</code></pre> <pre><code>use radiate::*;\n\nlet mutator = ScrambleMutator::new(0.1);\n</code></pre>"},{"location":"source/alters/mutators/#invert","title":"Invert","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Mutation rate (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Reverses the order of a segment of <code>genes</code></li> <li>Best for: Ordered sequences where reverse ordering might be beneficial</li> <li>Example: Helpful in permutation problems where reverse ordering of segments might lead to better solutions</li> <li>Compatible with: <code>BitGene</code>, <code>CharGene</code>, <code>FloatGene</code>, <code>IntGene&lt;I&gt;</code>, <code>PermutationGene&lt;A&gt;</code></li> </ul> <p><code>InvertMutator</code> is a segment inversion mutator. It randomly selects a segment of the <code>chromosome</code> and inverts the order of the <code>genes</code> within that segment.</p>  Python Rust <pre><code>import radiate as rd\n\nmutator = rd.InvertMutator(rate=0.1)\n</code></pre> <pre><code>use radiate::*;\n\nlet mutator = InvertMutator::new(0.1);\n</code></pre>"},{"location":"source/alters/mutators/#polynomial","title":"Polynomial","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Mutation rate (0.0 to 1.0)</li> <li><code>eta</code>: f32 - Exponent for polynomial mutation</li> </ul> <ul> <li>Purpose: Applies a polynomial mutation to the genes</li> <li>Best for: Continuous optimization problems</li> <li>Example: Multi-objective optimization, bounded domains where classic Gaussian mutation may overshoot</li> <li>Compatible with: <code>FloatGene</code></li> </ul> <p>The <code>PolynomialMutator</code> applies a polynomial mutation to the genes of a chromosome. This provides a bounded and unbiased mutation to genes where you care about the distribution of the mutation. Unlike Gaussian mutation, Polynomial can give more control over the tail behavior.</p> <p>The <code>eta</code> parameter controls the shape of the mutation distribution. A higher <code>eta</code> value results in a more exploratory mutation, while a lower value makes the mutation more exploitative. For example, a low <code>eta</code> (1.0-5.0) leads to bigger mutations, while a high value (20.0-100.0) leads to smaller, more fine grained mutations.</p>  Python Rust <pre><code>import radiate as rd\n\nmutator = rd.PolynomialMutator(rate=0.1, eta=20.0)\n</code></pre> <pre><code>use radiate::*;\n\nlet mutator = PolynomialMutator::new(0.1, 20.0);\n</code></pre>"},{"location":"source/alters/mutators/#jitter","title":"Jitter","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Mutation rate (0.0 to 1.0)</li> <li><code>magnitude</code>: f32 - Maximum jitter magnitude</li> </ul> <ul> <li>Purpose: Adds small random perturbations to gene values</li> <li>Best for: Fine-tuning solutions in continuous spaces</li> <li>Example: Useful for exploring the neighborhood of a solution</li> <li>Compatible with: <code>FloatGene</code></li> </ul> <p>The <code>JitterMutator</code> adds small random perturbations to the values of a <code>gene</code> within a <code>chromosome</code>. A random value is sampled from a uniform distribution between [-1, 1], then it is scaled by the <code>magnitude</code> parameter and added to the current gene value. This mutation operator is particularly useful for fine-tuning solutions in continuous spaces, as it allows for small adjustments that can help explore the local neighborhood of a solution.</p>  Python Rust <pre><code>import radiate as rd\n\nmutator = rd.JitterMutator(rate=0.1, magnitude=0.5)\n</code></pre> <pre><code>use radiate::*;\n\nlet mutator = JitterMutator::new(0.1, 0.5);\n</code></pre>"},{"location":"source/alters/rate/","title":"Rates","text":"<p>Rates are used to control the application frequency of alters. They can be static (fixed) or dynamic (changing over time). Radiate provides several built-in rate strategies to help you fine-tune the behavior of the alterers. Each mutator and crossover in Radiate accepts a <code>rate</code> parameter. In Python, the <code>rate</code> parameter can be either a float (for fixed rates) or an instance of the <code>Rate</code> class (for dynamic rates). In Rust, the <code>rate</code> parameter is anything that implements <code>Into&lt;Rate&gt;</code>. Below we can see the available rate strategies generated by the code snippet:</p> <pre><code>import radiate as rd\n\nrate = rd.Rate...\n\nrates = []\nfor i in range(100):\n    rates.append(rate.value(i))\n</code></pre>"},{"location":"source/alters/rate/#fixed","title":"Fixed","text":"<ul> <li>Purpose: Applies a constant rate throughout the evolution process - this is the default behavior and can be thought of as the \"standard\" rate.</li> </ul>  Python Rust <pre><code>import radiate as rd\n\nrate = rd.Rate.fixed(0.1)\n</code></pre> <pre><code>use radiate::*;\n\nlet rate = Rate::fixed(0.1);\n</code></pre>"},{"location":"source/alters/rate/#linear","title":"Linear","text":"<ul> <li>Purpose: Gradually changes the rate from a starting value to an ending value over a specified duration, allowing for a smooth transition in the application frequency of the alterer.</li> </ul>  Python Rust <pre><code>import radiate as rd\n\nrate = rd.Rate.linear(start=0.1, end=0.9, duration=25)\n</code></pre> <pre><code>use radiate::*;\n\nlet rate = Rate::linear(0.1, 0.9, 25);\n</code></pre>"},{"location":"source/alters/rate/#stepwise","title":"Stepwise","text":"<ul> <li>Purpose: Changes the rate at specified intervals, allowing for abrupt changes in the application frequency of the alterer.</li> </ul>  Python Rust <pre><code>import radiate as rd\n\nsteps = [(0, 0.1), (25, 0.5), (75, 0.9)]\nrate = rd.Rate.stepwise(steps)\n</code></pre> <pre><code>use radiate::*;\n\nlet steps = vec![(0, 0.1), (25, 0.5), (75, 0.9)];\nlet rate = Rate::stepwise(steps);\nlet rate = Rate::from(steps);\n</code></pre>"},{"location":"source/alters/rate/#sine-cyclical","title":"Sine Cyclical","text":"<ul> <li>Purpose: Oscillates the rate between a minimum and maximum value over a specified period, allowing for periodic changes in the application frequency of the alterer.</li> </ul>  Python Rust <pre><code>import radiate as rd\n\nrate = rd.Rate.sine(min=0.1, max=0.9, periods=10)\n</code></pre> <pre><code>use radiate::*;\n\nlet rate = Rate::cyclical(0.1, 0.9, 10, \"sine\");\n</code></pre>"},{"location":"source/alters/rate/#triangular-cyclical","title":"Triangular Cyclical","text":"<ul> <li>Purpose: Oscillates the rate between a minimum and maximum value over a specified period using a triangular wave, allowing for periodic changes in the application frequency of the alterer.</li> </ul>  Python Rust <pre><code>import radiate as rd\n\nrate = rd.Rate.triangular(min=0.1, max=0.9, periods=10)\n</code></pre> <pre><code>use radiate::*;\n\nlet rate = Rate::cyclical(0.1, 0.9, 10, \"triangular\");\n</code></pre>"},{"location":"source/alters/rate/#exponential","title":"Exponential","text":"<ul> <li>Purpose: Changes the rate exponentially from a starting value to an ending value over a specified duration, allowing for rapid changes in the application frequency of the alterer.</li> </ul>  Python Rust <pre><code>import radiate as rd\n\nrate = rd.Rate.exp(start=0.5, end=0.1, half_life=25)\n</code></pre> <pre><code>use radiate::*;\n\nlet rate = Rate::exponential(0.5, 0.1, 25);\n</code></pre>"},{"location":"source/diversity/","title":"Diversity","text":"<p>Diversity is an opt-in aspect of radiate's genetic algorithm. At its core, this operator helps maintain a healthy population and prevent premature convergence. By using this operator, the <code>GeneticEngine</code> will split the <code>population</code> up into <code>species</code> by measuring the genetic distance, or diversity, between individuals during the evolution process. Its important to note that adding a diversity operator will increase the computational cost of the algorithm, so it should be used judiciously based on the problem at hand.</p>"},{"location":"source/diversity/#overview","title":"Overview","text":"<p>Diversity in Radiate is implemented through two main components:</p> <ol> <li>Diversity Measurement: Methods to quantify how different individuals are from each other. This is typically done by measuring the genetic distance between individuals - meaning the actual <code>chromosomes</code> and <code>genes</code> that make up the individuals.</li> <li>Species Management: Mechanisms to group similar individuals and maintain population diversity</li> </ol>"},{"location":"source/diversity/#species-management","title":"Species Management","text":"<p>Radiate implements species management to maintain population diversity through several mechanisms:</p>"},{"location":"source/diversity/#species-threshold","title":"Species Threshold","text":"<p>The species threshold determines how similar individuals need to be to be considered part of the same <code>species</code>. A lower threshold will result in more species being formed, while a higher threshold will group more individuals into fewer species. This is crucial for controlling the balance between exploration and exploitation in the population. All of this is controlled by the <code>species_threshold</code> parameter in the engine:</p>  Python Rust <pre><code>import radiate as rd\n\nengine = rd.GeneticEngine(\n    codec=your_codec,\n    fitness_func=your_fitness_func,\n    diversity=diversity,\n    species_threshold=.5  # Default value\n)\n</code></pre> <pre><code>use radiate::*;\n\nlet engine = GeneticEngine::builder()\n    // ... other parameters ...\n    .diversity(your_diversity)\n    .species_threshold(0.5) // Default value\n    // ... other parameters ...\n    .build();\n</code></pre> <p>A higher threshold means:</p> <ul> <li>More individuals will be considered part of the same species resulting in a fewer number of species</li> <li>Less diversity in the <code>population</code></li> <li>Faster convergence</li> </ul> <p>A lower threshold means:</p> <ul> <li>Fewer individuals will be considered part of the same species</li> <li>More diversity in the <code>population</code></li> <li>Slower convergence</li> </ul>"},{"location":"source/diversity/#species-age","title":"Species Age","text":"<p>The <code>ecosystem</code> tracks the age of <code>species</code> to prevent stagnation, if a <code>species</code> reaches the given age limit without improvement, it will be removed from the <code>population</code>. This is controlled by the <code>max_species_age</code> parameter:</p>  Python Rust <pre><code>import radiate as rd\n\nengine = rd.GeneticEngine(\n    codec=your_codec,\n    fitness_func=your_fitness_func,\n    diversity=diversity,\n    species_threshold=.5  # Default value\n    max_species_age=20  # Default value\n)\n</code></pre> <pre><code>use radiate::*;\n\nlet engine = GeneticEngine::builder()\n    // ... other parameters ...\n    .diversity(your_diversity)\n    .species_threshold(0.5) // Default value\n    .max_species_age(20) // Default value\n    // ... other parameters ...\n    .build();\n</code></pre> <p>This helps by:</p> <ul> <li>Limiting how long a species can survive without improvement</li> <li>Preventing dominant species from taking over the population</li> <li>Encouraging exploration of new solutions</li> </ul>"},{"location":"source/diversity/#best-practices","title":"Best Practices","text":""},{"location":"source/diversity/#choosing-a-diversity-measure","title":"Choosing a Diversity Measure","text":"<ol> <li> <p>For Binary/Discrete Problems:</p> <ul> <li>Use Hamming Distance</li> <li>Good for problems where exact matches matter</li> <li>Example: Binary optimization, discrete scheduling</li> </ul> </li> <li> <p>For Continuous Problems:</p> <ul> <li>Use Euclidean Distance</li> <li>Better for problems where magnitude of differences matters</li> <li>Example: Parameter optimization, function approximation</li> </ul> </li> </ol>"},{"location":"source/diversity/#setting-species-threshold","title":"Setting Species Threshold","text":"<ol> <li> <p>Start Conservative:</p> <ul> <li>Begin with the default value (<code>0.5</code>)</li> <li>Monitor population diversity</li> <li>Adjust based on convergence behavior</li> </ul> </li> <li> <p>Adjust Based on Problem:</p> <ul> <li>For problems requiring high diversity: Use lower values (<code>0.05</code>-<code>0.2</code>)</li> <li>For problems needing faster convergence: Use higher values (<code>0.5</code>-<code>1.0</code>)</li> </ul> </li> </ol>"},{"location":"source/diversity/#age-limits","title":"Age Limits","text":"<ol> <li>Species Age:<ul> <li>Default (<code>20</code>) works well for most problems</li> <li>Increase for complex problems requiring more exploration</li> <li>Decrease for problems where quick convergence is desired</li> </ul> </li> </ol>"},{"location":"source/diversity/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li> <p>Premature Convergence:</p> <ul> <li>Problem: Population converges too quickly to suboptimal solutions</li> <li>Solution: <ul> <li>Lower the species threshold</li> <li>Increase max_species_age</li> <li>Use a more aggressive mutation rate</li> </ul> </li> </ul> </li> <li> <p>Excessive Diversity:</p> <ul> <li>Problem: Population fails to converge</li> <li>Solution:<ul> <li>Increase the species threshold</li> <li>Decrease max_species_age</li> <li>Adjust selection pressure</li> </ul> </li> </ul> </li> <li> <p>Stagnation:</p> <ul> <li>Problem: Population stops improving</li> <li>Solution:<ul> <li>Decrease max_phenotype_age</li> <li>Increase mutation rate</li> <li>Adjust species threshold</li> </ul> </li> </ul> </li> </ol>"},{"location":"source/diversity/distance/","title":"Distance","text":"<p>Distance measurements are used to quantify the distance between individuals in a population. Radiate provides several built-in distance measures that can be used to maintain diversity within the genetic algorithm. </p>"},{"location":"source/diversity/distance/#hamming-distance","title":"Hamming Distance","text":"<p>Compatible with: <code>FloatGene</code>, <code>IntGene&lt;I&gt;</code>, <code>BitGene</code>, <code>CharGene</code>, <code>PermuationGene&lt;A&gt;</code></p> <p>The Hamming Distance measures diversity by counting the number of positions at which corresponding genes are different, normalized by the total number of genes. This is particularly useful for:</p> <ul> <li>Binary or discrete genetic representations</li> <li>Problems where exact matches are important</li> <li>Cases where you want to measure diversity based on exact gene differences</li> </ul>  Python Rust <pre><code>import radiate as rd\n\ndiversity = rd.HammingDistance()\n</code></pre> <pre><code>use radiate::*;\n\nlet diversity = HammingDistance::new();\n</code></pre>"},{"location":"source/diversity/distance/#euclidean-distance","title":"Euclidean Distance","text":"<p>Compatible with: <code>FloatGene</code>, <code>IntGene&lt;I&gt;</code></p> <p>The Euclidean Distance calculates the square root of the sum of squared differences between corresponding <code>genes</code>' <code>alleles</code>, normalized by the number of genes. This is ideal for:</p> <ul> <li>Continuous genetic representations</li> <li>Problems where the magnitude of differences matters</li> <li>Cases where you want to measure diversity based on numerical distances</li> </ul>  Python Rust <pre><code>import radiate as rd\n\ndiversity = rd.EuclideanDistance()\n</code></pre> <pre><code>use radiate::*;\n\nlet diversity = EuclideanDistance::new();\n</code></pre>"},{"location":"source/diversity/distance/#cosine-distance","title":"Cosine Distance","text":"<p>Compatible with: <code>FloatGene</code>, <code>IntGene&lt;I&gt;</code></p> <p>The Cosine Distance measures diversity by calculating the cosine similarity between the vectors representing individuals. This is particularly useful for:</p> <ul> <li>High-dimensional spaces</li> <li>Problems where the direction of the vector matters more than its magnitude</li> <li>Cases where you want to measure diversity based on the orientation of the gene vectors</li> </ul>  Python Rust <pre><code>import radiate as rd\n\ndiversity = rd.CosineDistance()\n</code></pre> <pre><code>use radiate::*;\n\nlet diversity = CosineDistance::new();\n</code></pre>"},{"location":"source/diversity/distance/#neat-distance","title":"Neat Distance","text":"<p>Compatible with: <code>GraphNode&lt;Op&lt;f32&gt;&gt;</code></p> <p>The Neat Distance measures diversity by using the NEAT (NeuroEvolution of Augmenting Topologies) distance metric, which considers both structural and weight differences between neural network representations. This is particularly useful for:</p> <ul> <li>Neural network evolution</li> <li>Problems where both topology and weight differences matter</li> <li>Cases where you want to measure diversity based on neural network structure and weights</li> </ul>  Python Rust <pre><code>import radiate as rd\n\n# Parameters are: c1, c2, c3 - coefficients for excess genes, disjoint genes,\n# and average weight differences respectively\ndiversity = rd.NeatDistance(excess=0.1, disjoint=1.0, weight_diff=0.5)\n</code></pre> <p>requires <code>gp</code> feature flag</p> <pre><code>use radiate::*;\n\n// Parameters are: c1, c2, c3 - coefficients for excess genes, disjoint genes,\n// and average weight differences respectively\nlet diversity = NeatDistance::new(0.1, 1.0, 0.5);\n</code></pre>"},{"location":"source/diversity/example/","title":"Example","text":"<p>Lets add on to our example - evolving a simple function: finding the best values for <code>y = ax + b</code> where we want to find optimal values for <code>a</code> and <code>b</code>. We'll keep the previous inputs the same as before, but now we add <code>diversity</code> to the <code>GeneticEngine</code>.</p>  Python Rust <pre><code>import radiate as rd\n\n# Define a fitness function that uses the decoded values\ndef fitness_function(individual: list[float]) -&gt; float:    \n    # Calculate how well these parameters fit your data\n    a = individual[0]\n    b = individual[1]\n    return calculate_error(a, b)  # Your error calculation here\n\n# Create a codec for two parameters (a and b)\ncodec = rd.FloatCodec.vector(\n    length=2,                  # We need two parameters: a and b\n    init_range=(-1.0, 1.0),    # Start with values between -1 and 1\n    bounds=(-10.0, 10.0)       # Allow evolution to modify the values between -10 and 10\n)\n\n# Use Boltzmann selection for offspring - individuals which\n# will be used to create new individuals through mutation and crossover\noffspring_selector = rd.BoltzmannSelector(temp=4)\n\n# Use tournament selection for survivors - individuals which will \n# be passed down unchanged to the next generation\nsurvivor_selector = rd.TournamentSelector(k=3)\n\n# Define the alterers - these will be applied to the selected offspring\n# to create new individuals. They will be applied in the order they are defined.\nalters = [\n    rd.GaussianMutator(rate=0.1),\n    rd.BlendCrossover(rate=0.8, alpha=0.5)\n]\n\n# Define the diversity measure\ndiversity = rd.HammingDistance()  # or rd.EuclideanDistance() for continuous problems\n\n# Create the evolution engine\nengine = rd.GeneticEngine(\n    codec=codec,\n    fitness_func=fitness_function,\n    offspring_selector=offspring_selector,\n    survivor_selector=survivor_selector,\n    alters=alters,\n    diversity=diversity,  # Add the diversity measure\n    species_threshold=0.5,  # Default value\n    max_species_age=20,  # Default value\n    # ... other parameters ...\n)\n\n# Run the engine\nresult = engine.run([rd.ScoreLimit(0.01), rd.GenerationsLimit(1000)])\n</code></pre> <pre><code>use radiate::*;\n\n// Define a fitness function that uses the decoded values\nfn fitness_fn(individual: Vec&lt;f32&gt;) -&gt; f32 {\n    let a = individual[0];\n    let b = individual[1];\n    calculate_error(a, b)  // Your error calculation here\n}\n\n// This will produce a Genotype&lt;FloatChromosome&gt; with 1 FloatChromosome which\n// holds 2 FloatGenes (a and b), each with a value between -1.0 and 1.0 and a bound between -10.0 and 10.0\nlet codec = FloatCodec::vector(2, -1.0..1.0).with_bounds(-10.0..10.0);\n\n// Use Boltzmann selection for offspring - individuals which\n// will be used to create new individuals through mutation and crossover\nlet offspring_selector = BoltzmannSelector::new(4.0);\n\n// Use tournament selection for survivors - individuals which will\n// be passed down unchanged to the next generation\nlet survivor_selector = TournamentSelector::new(3);\n\n// Define some alters \nlet alters = alters![\n    GaussianMutator::new(0.1),\n    BlendCrossover::new(0.8, 0.5)\n];\n\n// Define the diversity measure\nlet diversity = HammingDistance::new(); // or EuclideanDistance::new() for continuous problems\n\nlet mut engine = GeneticEngine::builder()\n    .codec(codec)\n    .offspring_selector(offspring_selector)\n    .survivor_selector(survivor_selector)\n    .fitness_fn(fitness_fn)\n    .alterers(alters) \n    .diversity(diversity)       // Add the diversity measure\n    .species_threshold(0.5)     // Default value\n    .max_species_age(20)        // Default value\n    // ... other parameters ...\n    .build();\n\n// Run the engine\nlet result = engine.run(|generation| {\n    // Now because we have added diversity, the ecosystem will include species like such:\n    let species = generation.species().unwrap();\n    println!(\"Species count: {}\", species.len());\n    generation.index() &gt;= 1000 || generation.score().as_f32() &lt;= 0.01\n});\n</code></pre>"},{"location":"source/engine/","title":"Genetic Engine","text":"<p>The <code>GeneticEngine</code> is the core component. Once built, it manages the entire evolutionary process, including population management, fitness evaluation, and genetic operations. The engine itself is essentially a large iterator that produces <code>Generation</code> objects representing each generation.</p>"},{"location":"source/engine/#epochs","title":"Epochs","text":"<p>Each epoch represents a single generation in the evolutionary process. An epoch contains information related not only the current generation, but also the engine's state at that point in time. This is the primary output of the engine, and it can be used to track progress, visualize results, or make decisions based on the evolutionary process. </p>"},{"location":"source/engine/#single-objective-epoch","title":"Single-Objective Epoch","text":"<p>This is the default epoch for the engine - <code>Generation</code>. It contains:</p> <ul> <li>The generation number</li> <li><code>Ecosystem</code> information (population, species, etc.)</li> <li>Score, which is the fitness of the best individual in the generation</li> <li>Value, which is the decoded value of the best individual</li> <li>Performance metrics (e.g., time taken)</li> <li>The Objective (max or min). The fitness objective being optimized, used for comparison and decision making during the evolutionary process.</li> </ul>  Python Rust <pre><code>import radiate as rd\n\n# Create an engine\nengine = rd.GeneticEngine(\n    codec=rd.FloatCodec.scalar(0.0, 1.0), \n    fitness_fn=my_fitness_fn,  # Single objective fitness function\n    # ... other parameters ...\n)\n\n# Run the engine for 100 generations\nresult = engine.run(rd.GenerationsLimit(100))\n\n# Get the best individual's decoded value \nvalue = result.value() # float \n\n# Get the score (fitness) of the best individual or epoch score\nscore = result.score()  # List[float] - note that this is a list. \n# In this scenario, the engine is configured for single-objective optimization,\n# so the list will contain a single value.\n\n# Get the population of the engine's ecosystem\npopulation = result.population()  # Population object\n\n# Get the index of the epoch (number of generations)\nindex = result.index()  # int\n\n# Get the metrics of the engine\nmetrics = result.metrics()  # MetricSet object\n\n# Get the objective of the engine\nobjective = result.objective()  # list[str] | str (list[str] if multi-objective) - \"min\" or \"max\"\n</code></pre> <pre><code>use radiate::*;\n\n// Create an engine of type:\n// `GeneticEngine&lt;FloatChromosome, f32&gt;`\n//\n// Where the `epoch` is `Generation&lt;FloatChromosome, f32&gt;`\nlet mut engine = GeneticEngine::builder()\n    .codec(FloatCodec::scalar(0.0..1.0)) \n    .fitness_fn(|genotype: f32| my_fitness_fn(genotype)) // Return a single fitness score\n    // ... other parameters ...\n    .build();\n\n// Run the engine for 100 generations - the result will be a `Generation&lt;FloatChromosome, f32&gt;`\nlet result = engine.run(|generation: Generation&lt;FloatChromosome, f32&gt;| {\n    generation.index() &gt;= 100\n});\n\n// -- or using the engine's iterator --\nlet result = engine.iter().take(100).last().unwrap();\n\n// Get the best individual's decoded value and fitness score:\nlet best_value: f32 = result.value();\n\n// Get the score (fitness) of the best individual (or epoch score):\nlet best_score: Score = result.score();\n\n// Get the index of the epoch (number of generations):\nlet index: usize = result.index();\n\n// Get the ecosystem level information:\n// Note - the result needs to be 'mut' to access these methods as \n// they may require mutable access internally - caching, etc.\nlet ecosystem: Ecosystem&lt;FloatChromosome&gt; = result.ecosystem();\nlet population: Population&lt;FloatChromosome&gt; = ecosystem.population();\nlet species: Option&lt;&amp;[Species&lt;FloatChromosome&gt;]&gt; = ecosystem.species();\n\n// Get performance metrics:\nlet metrics: MetricSet = result.metrics();\n\n// Get evolution duration (also available in metrics):\nlet time: Duration = result.time();\n\n// Get the objective of the engine\nlet objective: &amp;Objective = result.objective(); \n</code></pre>"},{"location":"source/engine/#multi-objective-epoch","title":"Multi-Objective Epoch","text":"<p>When the engine is configured for multi-objective optimization, the engine <code>Generation</code> will have a <code>ParetoFront</code> attached to it. The only difference between the single-objective and multi-objective is the availablity of the <code>ParetoFront</code> and the <code>fitness</code> value. The <code>fitness</code> value will be a list of scores, one for each objective being optimized.</p>  Python Rust <pre><code>import radiate as rd\n\n# Create an engine\nengine = rd.GeneticEngine(\n    codec=rd.FloatCodec.scalar(0.0, 1.0), \n    fitness_fn=my_fitness_fn,  # Multi-objective fitness function\n    objective=['min', 'max', ...],  # Specify multi-objective optimization\n    # ... other parameters ...\n)\n\n# Run the engine for 100 generations\nresult = engine.run(rd.GenerationsLimit(100))\n\n# Everything in the multi-objective epoch is the same as the single-objective epoch, except for the value. \n# The function call to `front()` will return a `ParetoFront` object while `value()` will return None.:\nfront = result.front()  # ParetoFront object\n# This is of type `Front` with `FrontValue` members.\nvalue_at_index_0 = front[0]  # FrontValue object\nall_values = front.values()  # list[FrontValue]\n\n# Get the members of the Pareto front:\nscore = all_values[0].score() # list[float] - multi-objective score\ngenotype = all_values[0].genotype()  # Genotype object\n</code></pre> <pre><code>use radiate::*;\n\n// Create an engine of type:\n// `GeneticEngine&lt;FloatChromosome, f32&gt;`\n//\n// Where the `epoch` is `Generation&lt;FloatChromosome, f32&gt;`\nlet mut engine = GeneticEngine::builder()\n    .codec(FloatCodec::scalar(0.0..1.0)) \n    .multi_objective(vec![Objective::Min, Objective::Max]) // Specify multi-objective optimization\n    .fitness_fn(|genotype: f32| my_fitness_fn(genotype)) // Return a multi-objective fitness score\n    // ... other parameters ...\n    .build();\n\n// Run the engine for 100 generations - the result will be a `MultiObjectiveGeneration&lt;FloatChromosome&gt;`\nlet result = engine.run(|generation: Generation&lt;FloatChromosome, 32&gt;| {\n    generation.index() &gt;= 100\n});\n\n// -- or using the engine's iterator --\nlet result = engine.iter().take(100).last().unwrap();\n\n// Everything in this generation is the same as the single-objective epoch, except that \n// the function call to `front()` will return a `ParetoFront` object.:\n// This will be of type `Front&lt;Phenotype&lt;FloatChromosome&gt;&gt;`\nlet front: Option&lt;&amp;Front&lt;Phenotype&lt;FloatChromosome&gt;&gt;&gt; = result.front();\n\n// Get the members of the Pareto front:\nlet individuals: &amp;[Arc&lt;Phenotype&lt;FloatChromosome&gt;&gt;] = front.values();\n</code></pre>"},{"location":"source/engine/#running","title":"Running","text":"<p>Radiate provides multiple ways to run the <code>GeneticEngine</code>. </p> <ol> <li> <p>Run Method</p> <p>The <code>run</code> method provides a more traditional way to run the engine. In rust it accepts a closure that takes the current epoch as an argument and returns a boolean indicating whether to stop the engine. In python, it accepts either a single limit or a list of limits that define the stopping conditions for the engine. The <code>run</code> method also accepts a <code>log</code>, <code>ui</code>, &amp; <code>checkpoint</code> parameter to enable logging, a terminal UI, or checkpointing respectively.</p> </li> <li> <p>Iterator API </p> <p>The <code>GeneticEngine</code> is an inherently iterable concept, as such we can treat the engine as an iterator. Because of this we can use it in a <code>for</code> loop or with iterator methods like <code>map</code>, <code>filter</code>, etc. We can also extend the iterator with custom methods to provide additional functionality, such as running until a certain fitness (score) is reached, time limit, or convergence. These custom methods are essentially sytactic sugar for 'take_until' or 'skip_while' style iterators.</p> <p>During any sort of optimization task its useful to visually see the progress of the engine. Using the iterator API, we do this by calling <code>logging()</code> on the engine's iterator. This will give us nice console output of the progress provided by the tracing project.</p> <p>Stopping Condition</p> <p>The engine's iterator is an 'streaming' or 'infinite iterator', meaning it will continue to produce epochs until a stopping condition, a <code>break</code> or a <code>return</code> is met. So, unless you want to run the engine indefinitely, you should always use a method like <code>take</code>, <code>until</code>, or <code>last</code> to limit the number of epochs produced.</p> </li> </ol>  Python Rust <pre><code>import radiate as rd\n\n# Create an engine\nengine = rd.GeneticEngine(\n    codec=rd.FloatCodec.scalar(0.0, 1.0), \n    fitness_func=my_fitness_fn,  # Some fitness function\n    # ... other parameters ...\n)\n\n# use a simple for loop to iterate through 100 generations\nfor epoch in engine:\n    if epoch.index() &gt;= 100:\n        break\n    print(f\"Generation {epoch.index()}: Score = {epoch.score()}\")\n\n# just use the next() function to get the next epoch\nwhile True:\n    # the 'next' function calls the iterator internally &amp; is very efficient, the only clones that happen \n    # will be on the first call to a method that requires ownership of the epoch data.\n    epoch = next(engine)\n    if epoch.index() &gt;= 100:\n        break\n    print(f\"Generation {epoch.index()}: Score = {epoch.score()}\")\n\n# --- or using the engine's Run method with limits ---\n\n# Limits - run until a score target is reached\nscore_limit = rd.ScoreLimit(0.01)\ngenerations_limit = rd.GenerationsLimit(100)\nseconds_limit = rd.SecondsLimit(60)\n# window and epsilon for convergence - how close the scores must be over the window to consider convergence\nconvergence_limit = rd.ConvergenceLimit(window=50, epsilon=0.01) \n\n# Log the progress of the engine to the console\nresult = engine.run([\n        score_limit,\n        generations_limit,\n        seconds_limit,\n        convergence_limit\n    ],\n    log=True,\n    ui=True, # Enable terminal UI - if enabled, log is ignored\n    checkpoint=(10, \"checkpoint.json\") # checkpoint every 10 generations to 'checkpoint.json'\n)\n</code></pre> <pre><code>use radiate::*;\nuse std::time::Duration;\n\n// Create an engine\nlet mut engine = GeneticEngine::builder()\n    .codec(FloatCodec::scalar(0.0..1.0)) \n    .fitness_fn(|genotype: f32| my_fitness_fn(genotype))\n    // ... other parameters ...\n    .build();\n\n// 1.) use a simple for loop to iterate through 100 generations\nfor epoch in engine.iter().take(100) {\n    println!(\"Generation {}: Score = {}\", epoch.index(), epoch.score().as_f32());\n}\n\n// 2.) use the iterator's custom methods to run until a score target is reached\nlet target_score = 0.01;\nlet result = engine.iter().until_score(target_score).last().unwrap();\n\n// 3.) run until a time limit is reached\nlet time_limit = Duration::from_secs(60);\nlet result = engine.iter().until_duration(time_limit).last().unwrap();\n\n// 4.) run until convergence\nlet window = 50;\nlet epsilon = 0.01; // how close the scores must be over the window to consider convergence\nlet result = engine.iter().until_convergence(window, epsilon).last().unwrap();\n\n// 5.) log the progress of the engine to the console using the `logging()` method\nlet result = engine.iter().logging().until_seconds(10).last().unwrap();\n\n// 5.) combined limits\nlet result = engine\n    .iter()\n    .logging()\n    .limit((\n        Limit::Generation(100),\n        Limit::Seconds(Duration::from_secs_f64(2.0)),\n        Limit::Score(0.01),\n    ))\n    .last()\n    .unwrap();\n\n// 6.) metrics limit - stop after 1000 evaluations\nlet result = engine\n    .iter()\n    .until_metric(metric_names::EVALUATION_COUNT, |metric| {\n        metric.value_sum().map(|v| v &gt;= 1000.0).unwrap_or(false)\n    })\n    .last()\n    .unwrap();\n\n// 7.) Checkpointing - save the engine state every 10 generations\nlet checkpoint_path = \"checkpoint.json\";\nlet result = engine\n    .iter()\n    .checkpoint(10, checkpoint_path) \n    .take(100)\n    .last()\n    .unwrap();\n\n// 8.) Using the engine's run method with a closure - stop after 100 generations\nlet result = engine.run(|generation: &amp;Generation&lt;FloatChromosome, Vec&lt;f32&gt;&gt;| {\n    generation.index() &gt;= 100\n});\n</code></pre>"},{"location":"source/engine/#control-interface","title":"Control Interface","text":"<p>The engine provides a control interface that allows for pausing, resuming, and stopping the evolutionary process from external contexts. For instance, you might want to pause or step through generations from another thread or based on user input.</p>  Python Rust <p>Not currently implemented.</p> <pre><code>use radiate::*;\nuse std::thread;\nuse std::time::Duration;\n\nlet mut engine = GeneticEngine::builder()\n    .minimizing()\n    .codec(IntCodec::vector(5, 0..100))\n    .fitness_fn(|geno: Vec&lt;i32&gt;| geno.iter().sum::&lt;i32&gt;())\n    .build();\n\nlet control = engine.control();\n\nlet handle = thread::spawn(move || {\n    // Run the engine for 1 second\n    let result = engine.iter().until_seconds(1_f64).last().unwrap();\n    // because we are running for only a second and are pausing the engine,\n    // the engine's internal time tracking should be very close to 1 second even \n    // though we paused it for +500ms\n    assert_eq!((result.seconds() - 1_f64).abs().round(), 0.0);\n});\n\nthread::sleep(Duration::from_millis(100));\ncontrol.set_paused(true);\n\n// Ensure the engine is paused for at least 500ms\nthread::sleep(Duration::from_millis(500));\ncontrol.set_paused(false);\nhandle.join().unwrap();\n</code></pre>"},{"location":"source/engine/#tips","title":"Tips","text":"<ul> <li>Use appropriate population sizes (100-500 for most problems)</li> <li>Enable parallel execution for expensive fitness functions</li> <li>Consider species-based diversity for complex landscapes</li> <li>Experiment with different mutation and crossover rates</li> <li>Monitor convergence and adjust parameters dynamically</li> <li>Utilize logging and checkpointing for long runs</li> <li>Leverage the control interface for interactive runs</li> </ul>"},{"location":"source/engine/metrics/","title":"Metrics","text":"<p>Metric collection in radiate is interwoven into every aspect of the evolutionary process. It uses the Kahan summation algorithm paired with Welford's one-pass online algorithm for fast, accurate, and numerically stable computation of statistics. All of this combined provides robust and reliable metric tracking throughout the evolutionary process. Using the <code>MetricSet</code> (a collection of independent <code>Metric</code>s) we can collect a whole host statistics that span the entire evolutionary process allowing us to gain deep insights into the evolutionary dynamics.</p>"},{"location":"source/engine/metrics/#metricset","title":"MetricSet","text":"<p>The <code>MetricSet</code> is an object (struct) provided to the user in two main forms:</p> <ol> <li>On the engine's <code>Generation</code> - given to the user after each epoch or each pass of the evolution process.</li> <li>Through the engine's eventing system. Various events emit metric data allowing the user to track metrics or derive their own in real-time.</li> </ol> <p>Each <code>metric</code> can include one or both of the following statistical types:</p> <ol> <li> <p>Statistic - for general numerical data</p> <p>The <code>Statistic</code> exposes a number of different statistical measures that can be used to summarize the data, such as, <code>last_value</code>, <code>count</code>, <code>min</code>, <code>max</code>, <code>mean</code>, <code>sum</code>, <code>variance</code>, <code>std_dev</code>, <code>skewness</code>, and <code>kurtosis</code>. </p> </li> <li> <p>TimeStatistic - for time-based data</p> <p>Similarly, the <code>TimeStatistic</code> exposes the same measures, however the data is assumed to be time-based. As such, the results are expressed as a <code>Duration::from_secs_f32(value)</code>.</p> </li> </ol>"},{"location":"source/engine/metrics/#collection","title":"Collection","text":"<p>Along with the default metrics, each component will also collect metrics for the operations it performs. For example, each <code>Alterer</code> and <code>Selector</code> will collect metrics and be identified by their name. A few types of metrics will only be included if the parts of the engine which produce them are included. For instance, <code>species</code> level metrics will only be collected if the engine is configured to use species-based diversity. Also, <code>front</code> level metrics will only be collected if the engine is configured for multi-objective optimization. </p> <p>Note this does not include all possible metrics. Certain metrics are only collected under specific conditions or configurations, such as when using species-based diversity or multi-objective optimization.</p>"},{"location":"source/engine/metrics/#default-metrics","title":"Default Metrics","text":"<p>Metrics collected by default (always included):</p> Name Description <code>time</code> The time taken for the evolution process. <code>scores</code> The scores (fitness) of all the individuals evolved throughout the evolution process. <code>age</code> The age of all the individuals in the <code>Ecosystem</code> throughout the evolution process. <code>replace_age</code> The number of individuals replaced based on age. <code>replace_invalid</code> The number of individuals replaced based on invalid structure (e.g. Bounds) <code>genome_size</code> The size of each genome over the evolution process. This is usually static and doesn't change. <code>unique_members</code> The number of unique members in the <code>Ecosystem</code>. <code>unique_scores</code> The number of unique scores in the <code>Ecosystem</code>. <code>new_children</code> The number of new children created each generation through either mutation or crossover (or both). <code>survivor_count</code> The number of individuals that survived to the next generation - summation throughout the evolution process. <code>carryover_rate</code> The rate at which unique individuals are carried over to the next generation - <code>survivor_count</code> per generation / population size. <code>evaluation_count</code> The total number of evaluations performed per generation. <code>diversity_ratio</code> The ratio of unique scores to the size of the <code>Ecosystem</code>. <code>score_volatility</code> The volatility of the scores in the <code>Ecosystem</code>. This is calculated as the standard deviation of the scores / mean. <code>best_score_improvement</code> The improvement of the best score from the previous generation to the current generation - either a 1 or 0 each generation."},{"location":"source/engine/metrics/#multi-objective-metrics","title":"Multi-objective Metrics","text":"<p>Additional metrics collected when using multi-objective optimization:</p> Name Description <code>front_additions</code> The number of members added to the Pareto front each generation. <code>front_entropy</code> The entropy of the Pareto front throughout the evolution process - only calculated every 10 generations (its kinda an expensive calculation). <code>front_removals</code> The number of members removed from the Pareto front each generation. <code>front_comparisons</code> The number of comparisons made to update the Pareto front each generation. <code>front_size</code> The size of the Pareto front each generation. <code>front_filters</code> The number of times the Pareto front was filtered each generation."},{"location":"source/engine/metrics/#species-based-metrics","title":"Species-based Metrics","text":"<p>Additional metrics collected when using species-based diversity:</p> Name Description <code>species_count</code> The number of <code>species</code> in the 'Ecosystem`. <code>species_removed</code> The number of <code>species</code> removed based on stagnation. <code>species_created</code> The number of <code>species</code> created in the <code>Ecosystem</code>. <code>species_died</code> The number of <code>species</code> that have died in the <code>Ecosystem</code>. <code>species_age</code> The age of all the <code>species</code> in the <code>Ecosystem</code>. <code>species_age_fail</code> The count of species that have failed based on age each generation. <code>species_eveness</code> The evenness of the species distribution in the <code>Ecosystem</code>. <code>largest_species_share</code> The share of the largest species in the <code>Ecosystem</code>. <code>species_new_ratio</code> The ratio of new species created each generation."},{"location":"source/engine/metrics/#accessing-metrics","title":"Accessing Metrics","text":"<p>These can be accessed through the <code>metrics()</code> method of the epoch, which returns a <code>MetricSet</code>. </p>  Python Rust <pre><code>import radiate as rd\n\n# Create an engine\nengine = rd.GeneticEngine(\n    codec=rd.FloatCodec.scalar(0.0, 1.0), \n    fitness_fn=my_fitness_fn,  # Single objective fitness function\n    # ... other parameters ...\n)\n\n# Run the engine for 100 generations\nresult = engine.run(rd.GenerationsLimit(100))\n\n# Get the metrics of the engine\nmetrics = result.metrics()  # MetricSet object\ndf = metrics.to_polars()  # Convert metrics to a Polars DataFrame for analysis (if installed)\ndf = metrics.to_pandas()  # Convert metrics to a Pandas DataFrame for analysis (if installed)\n\n# Access specific metrics\ncarry_over = metrics['carryover_rate'].max() # Maximum carryover rate throughout evolution\n\nscores = metrics[\"scores\"] \nscore_mean = scores.mean()  \nscore_stddev = scores.stddev()  \nscore_variance = scores.variance()  \nscore_min = scores.min()  \nscore_max = scores.max()  \nscore_count = scores.count()  \nscore_skew = scores.skew()  \nscore_sum = scores.sum()\n\ntime = metrics[\"time\"].time_sum() \n\ntotal_time = time.time_sum()  \nmean_time = time.time_mean()  \nstddev_time = time.time_stddev()  \nvariance_time = time.time_variance()  \nmin_time = time.time_min()  \nmax_time = time.time_max()  \n\n# pretty-print the metrics dashboard\nprint(metrics.dashboard())\n</code></pre> <pre><code>// --- set up the engine ---\n\nlet result = engine.run(|ctx| {\n    // get the scroe metric from the generation context\n    let temp = ctx.metrics().get(\"scores\").unwrap();\n    // get the standard deviation of the score distribution\n    let std = temp.value_std_dev();\n\n    std &lt; 0.01 // Example condition to stop the engine\n});\n\n// Access the metrics from the result\nlet metrics: MetricSet = result.metrics();\n\n// pretty-print the metrics dashboard\nprintln!(\"{}\", metrics.dashboard())\n</code></pre>"},{"location":"source/engine/metrics/#tags","title":"Tags","text":"<p>All metrics have a sort of metadata which identifies them based on their characteristics or where they originate from. This can be used to filter and group metrics based on similar traits. For example, metrics related to time will have the <code>time</code> tag, while metrics related to <code>mutators</code> will have the <code>mutator</code> tag.</p>  Python Rust <pre><code>import radiate as rd\n\n# Create the evolution engine\nengine = rd.GeneticEngine(\n    codec=codec,\n    fitness_func=fitness_function,\n    # ... other parameters ...\n)\n\n# Run the engine\nresult = engine.run([rd.ScoreLimit(0.01), rd.GenerationsLimit(1000)])\n\n# Access the metrics from the result\nmetrics = result.metrics()\n\n# Get tags for a specific metric\ntags = metrics['scores'].tags()  # e.g., ['rd.Tag.SCORE', 'rd.Tag.STATISTIC', 'rd.Tag.DISTRIBUTION']\n\nfor metric in metrics.values_by_tag(rd.Tag.ALTERER):\n    # ... access all metrics related to alterers (crossover, mutation) ...\n</code></pre> <pre><code>use radiate::*;\n\n// Create the evolution engine\n\nlet engine = GeneticEngine::builder()\n    .codec(IntCodec::vector(10, 0..100))\n    .minimizing()\n    .fitness_fn(|geno: Vec&lt;i32&gt;| geno.iter().sum::&lt;i32&gt;())\n    .build();\n\n// Run the engine\nlet result = engine.run(|generation| generation.index() &gt;= 1000);\n\n// Access the metrics from the result\nlet metrics: MetricSet = result.metrics();\n\n// Get tags for a specific metric\nlet tags = metrics.get(\"scores\").unwrap().tags(); // [Tag::Score, Tag::Statistic, Tag::Distribution]\nfor metric in metrics.iter_tagged(TagKind::Alterer) {\n    // ... access all metrics related to alterers (crossover, mutation) ...\n}\n\n// Collect unique tags contained in the MetricSet\nlet unique_tags = metrics.tags().collect::&lt;Vec&lt;_&gt;&gt;();\n</code></pre> <p>Tags available:</p> Tag Description <code>Selector</code> Metrics related to selection mechanisms. <code>Alterer</code> Metrics related to alteration mechanisms (mutation, crossover). <code>Mutator</code> Metrics specifically related to mutation operations. <code>Crossover</code> Metrics specifically related to crossover operations. <code>Species</code> Metrics related to species-based diversity. <code>Failure</code> Metrics related to failures (e.g., invalid individuals). <code>Age</code> Metrics related to age-based operations. <code>Front</code> Metrics related to multi-objective optimization fronts. <code>Derived</code> Metrics that are derived from other metrics. <code>Other</code> Miscellaneous metrics that don't fit into other categories. <code>Statistic</code> Metrics that provide statistical measures. <code>Time</code> Metrics related to time measurements. <code>Distribution</code> Metrics that describe distributions (e.g., scores, ages). <code>Score</code> Metrics specifically related to fitness scores. <code>Rate</code> Metrics that represent rates (e.g., carryover rate)."},{"location":"source/genome/","title":"Understanding the Genome System","text":""},{"location":"source/genome/#introduction","title":"Introduction","text":"<p>In genetic algorithms, we need a way to represent and manipulate potential solutions to our problems. Radiate uses a genome system that breaks down genetic information into several key components. Think of it like a blueprint for building solutions, where each component has a specific role in creating and evolving individuals.</p>"},{"location":"source/genome/#ecosystem","title":"Ecosystem","text":""},{"location":"source/genome/#allele","title":"Allele","text":"<p>The basic unit.</p> <p>The <code>allele</code> is the smallest unit of genetic information in Radiate. It is a single value that can be used to represent a trait or characteristic of an individual. For example, an <code>allele</code> could represent a single bit in a binary string, a single character in a string, or a single number in a list of numbers. At its most basic level, an <code>allele</code> is the \"atom\" of genetic information that is used to express the genetic makeup of an individual - think of it as the \"letter\" in a genetic \"word\". For example, it could be:</p> <ul> <li>A number (like <code>42</code> or <code>3.14</code>)</li> <li>A character (like <code>A</code> or <code>?</code>)</li> <li>A boolean value (<code>true</code>/<code>false</code>)</li> <li>Any other basic value type</li> </ul>"},{"location":"source/genome/#gene","title":"Gene","text":"<p>The container.</p> <p>A <code>Gene</code> is a wrapper around an <code>allele</code> that adds functionality which is compatible with the genetic algorithm. It's like a container that not only holds the value, or <code>allele</code>, but also knows how to:</p> <ul> <li>Create new instances of itself</li> <li>Validate itself and its <code>allele</code></li> <li>Perform operations on its <code>allele</code> like addition, subtraction, or mutation</li> <li>Maintain constraints (like value ranges)</li> </ul> <p>Certain <code>Genes</code> have additional functionality that allows them to be manipulated in specific ways, such as the <code>FloatGene</code> and <code>IntGene&lt;I&gt;</code> which implement the <code>ArithmeticGene</code>. The <code>ArithmeticGene</code> trait provides methods for performing arithmetic operations on the <code>Gene</code>. Radiate provides several built-in gene types, however, you can also create custom genes to suit your specific needs. The core built-in genes include:</p> FloatGene <p>For evolving floating-point numbers. If the <code>allele</code> is not specified, it will be randomly initialized within the <code>value_range</code>. If the <code>value_range</code> is not specified, it will default to (<code>-1e10</code>, <code>1e10</code>). If the <code>bound_range</code> is not specified, it will default to <code>value_range</code>.</p>  Python Rust <pre><code>import radiate as rd\n\n# Create a float gene that can evolve between -1.0 and 1.0 but \n# must stay within -10.0 to 10.0 during evolution\ngene = rd.gene.float(\n    allele=0.5,                   # Current value\n    init_range=(-1.0, 1.0),      # Initial range\n    bounds=(-10.0, 10.0)     # Evolution bounds\n)\n</code></pre> <pre><code>use radiate::*;\n\n// Create a float gene that can evolve between -1.0 and 1.0 but \n// must stay within -10.0 to 10.0 during evolution\nlet gene = FloatGene::new(0.5, -1.0..1.0, -10.0..10.0);\n\n// Create a float gene with a randomly generated allele between -1.0 and 1.0\n// and bounds between -1.0 and 1.0\nlet gene = FloatGene::from(-1.0..1.0)\n\n// Create a float gene with a randomly generated allele between -1.0 and 1.0 with bounds between -10.0 and 10.0\nlet gene = FloatGene::from(-1.0..1.0, -10.0..10.0);\n\n// Create a float gene with an allele of 0.5 allele between -1.0 and 1.0 with bounds between -10.0 and 10.0\nlet gene = FloatGene::from((0.5, -1.0..1.0, -10.0..10.0));\n</code></pre> IntGene <p>For evolving integer values. If the <code>allele</code> is not specified, it will be randomly initialized within the <code>value_range</code>. If the <code>value_range</code> is not specified, it will default to (<code>-1e10</code>, <code>1e10</code>). If the <code>bound_range</code> is not specified, it will default to <code>value_range</code>. The <code>IntGene</code> holds a generic type <code>I</code> that implements the <code>Integer&lt;I&gt;</code> trait, which allows it to work with various integer types such as <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, and <code>u128</code>.</p>  Python Rust <pre><code>import radiate as rd\n\n# Create an integer gene that can evolve between -100 and 100\ngene = rd.gene.int(\n    allele=42,                     # Current value\n    init_range=(-10, 10),        # Initial range\n    bounds=(-100, 100)       # Evolution bounds\n)\n</code></pre> <pre><code>use radiate::*;\n\n// Create an integer gene that can evolve between -100 and 100\nlet gene = IntGene::new(42, -10..10, -100..100);\n\n// Create an integer gene with a randomly generated allele between -10 and 10 - specify the int type\nlet gene = IntGene::&lt;i8&gt;::from(-10..10);\n\n// Create an integer gene with a randomly generated allele between -10 and 10 with bounds between -100 and 100\nlet gene = IntGene::from(-10..10, -100..100);\n\n// Create an integer gene with an allele of 42 between -10 and 10 with bounds between -100 and 100\nlet gene = IntGene::from((42, -10..10, -100..100));\n</code></pre> BitGene <p>For evolving binary values. Radiate uses a <code>bool</code> as the allele for <code>BitGene</code>, which can be either <code>True</code> or <code>False</code>. </p>  Python Rust <pre><code>import radiate as rd\n\n# Create an bit gene with an allele of True - if the allele isn't specified, it will \n# be randomly initialized to True or False\ngene = rd.gene.bit(allele=True)\n</code></pre> <pre><code>use radiate::*;\n\n// Create an bit gene with a randomly generated allele of true or false.\nlet gene = BitGene::new();\n\n// Create a bit gene with an allele of true\nlet gene = BitGene::from(true); \n</code></pre> CharGene <p>For evolving character values. The <code>CharGene</code> uses a <code>char</code> as its allele, which can represent any single Unicode character. If the <code>allele</code> is not specified, it will be randomly initialized to a character within the specified <code>char_set</code>. If the <code>char_set</code> is not specified, it will default to the ASCII printable characters.</p>  Python Rust <pre><code>import radiate as rd\n\n# Create a character gene with an allele of 'A'\ngene = rd.gene.char(allele='A')\n\n# Create a character gene with a randomly generated allele from the set 'abc'\ngene = rd.gene.char(char_set='abc')  \n\n# Create a character gene from a set of chars \ngene = rd.gene.char(char_set='abc')\ngene = rd.gene.char(char_set=['a', 'b', 'c'])\n</code></pre> <pre><code>use radiate::*;\n\n// Create an char gene with a randomly generated allele from the ASCII printable characters\nlet gene = CharGene::default();\n\n// Create a char gene with a char_set of 'abc' of which the allele will be randomly chosen from\nlet gene = CharGene::from(\"abc\");\n\n// Create a char gene with an allele of 'A' from the char_set 'abc'\nlet gene = CharGene::from(('A', Arc::new(['a', 'b', 'c'])));\n</code></pre> PermutationGene <p>For evolving permutations of a set of values. The <code>PermutationGene</code> allows you to represent a single value from a list of unique values. It is useful for problems where the order of elements matters, such as the Traveling Salesman Problem.</p>  Python Rust <p> Under Construction </p> <p>This Gene is currently under construction and not yet available in the Python API.</p> <pre><code>use radiate::*;\n\n// Define a list of alleles the associated genes\nlet alleles = Arc::new(vec![1, 2, 3, 4]);\nlet genes = vec![\n    PermutationGene::new(0, Arc::clone(&amp;alleles)),\n    PermutationGene::new(1, Arc::clone(&amp;alleles)),\n    PermutationGene::new(2, Arc::clone(&amp;alleles)),\n    PermutationGene::new(3, Arc::clone(&amp;alleles)),\n];\n</code></pre>"},{"location":"source/genome/#chromosome","title":"Chromosome","text":"<p>The Collection.</p> <p>Each <code>Gene</code> is contained within a <code>Chromosome</code> and as such, each <code>Gene</code> has its own <code>Chromosome</code>. The <code>Chromosome</code> is a collection of <code>Genes</code> that represent a part or the whole of the genetic information of an individual. A <code>Chromosome</code> can be thought of as a \"chunk\" or vector of genetic information. For example, a <code>Chromosome</code> could represent a sequence of numbers, a string of characters, or a set of binary values among other things. The decision to define a <code>Chromosome</code> for each <code>Gene</code> was made to allow for more flexibility in the genetic information that can be represented. Think of it as a \"sentence\" made up of multiple \"words\" (genes). Each chromosome represents a specific part of your solution.</p> <p>For example, if you're evolving a neural network, you might have:</p> <ul> <li>One chromosome for the weights of the first layer</li> <li>Another chromosome for the weights of the second layer</li> <li>Each chromosome contains multiple genes (the individual weights)</li> </ul> <p>Because each <code>Chromosome</code> has an associated <code>Gene</code>, the built int chromosomes are defined as follows:</p> FloatChromosome <p>For evolving a sequence of floating-point numbers. It contains a vector of <code>FloatGene</code> instances.</p>  Python Rust <pre><code>import radiate as rd\n\n# Create a float chromosome with 5 genes, each initialized to a random value between -1.0 and 1.0\nchromosome = rd.chromosome.float(\n    length=5, \n    init_range=(-1.0, 1.0), \n    bounds=(-10.0, 10.0)\n)\n\n# Create a float chromosome with specific genes\ngenes = [rd.gene.float(allele=0.1), rd.gene.float(allele=0.2), rd.gene.float(allele=0.3)]\nchromosome_with_genes = rd.chromosome.float(genes=genes)\n</code></pre> <pre><code>use radiate::*;\n\n// Create a float chromosome with 5 genes, each initialized to a random value between -1.0 and 1.0\nlet chromosome = FloatChromosome::from((5, -1.0..1.0));\n\nlet bounded_chromosome = FloatChromosome::from((5, -1.0..1.0, -10.0..10.0));\n</code></pre> IntChromosome <p>For evolving a sequence of integer values. It contains a vector of <code>IntGene&lt;I&gt;</code> instances, where <code>I</code> is a generic type that implements the <code>Integer&lt;I&gt;</code> trait.</p>  Python Rust <pre><code>import radiate as rd\n\n# Create an integer chromosome with 5 genes, each initialized to a random value between -10 and 10\nchromosome = rd.chromosome.int(\n    length=5,\n    init_range=(-10, 10),\n    bounds=(-100, 100)\n)\n</code></pre> <pre><code>use radiate::*;\n\n// Create an integer chromosome with 5 genes, each initialized to a random value between -10 and 10\nlet chromosome = IntChromosome::&lt;i32&gt;::from((5, -10..10));\n\nlet bounded_chromosome = IntChromosome::&lt;i32&gt;::from((5, -10..10, -100..100));\n</code></pre> BitChromosome <p>For evolving a sequence of binary values. It contains a vector of <code>BitGene</code> instances.</p>  Python Rust <pre><code>import radiate as rd\n\n# Create a bit chromosome with 5 genes, each initialized to a random value of True or False\nchromosome = rd.chromosome.bit(length=5)\n</code></pre> <pre><code>use radiate::*;\n\n// Create a bit chromosome with 5 genes, each initialized to a random value of true or false\nlet chromosome = BitChromosome::new(5);\n</code></pre> CharChromosome <p>For evolving a sequence of character values. It contains a vector of <code>CharGene</code> instances.</p>  Python Rust <pre><code>import radiate as rd\n\n# Create a character chromosome with 5 genes, each initialized to a random character from the ASCII printable characters\nchromosome = rd.chromosome.char(length=5)\n\nchromosome_with_set = rd.chromosome.char(length=5, char_set='abc')\n</code></pre> <pre><code>use radiate::*;\n\n// Create a character chromosome with 5 genes, each initialized to\n// a random character from the provided char_set\nlet chromosome = CharChromosome::new((5, vec!['a', 'b', 'c']));\nlet chromosome_with_set = CharChromosome::from((5, \"abc\"));\n</code></pre> PermutationChromosome <p>For evolving a sequence of unique values. It contains a vector of <code>PermutationGene&lt;T&gt;</code> instances, where <code>T</code> is the type of the values in the permutation.</p>  Python Rust <p> Under Construction </p> <p>This Chromosome is currently under construction and not yet available in the Python API.</p> <pre><code>use radiate::*;\n\n// Define a list of alleles the associated genes\nlet alleles = Arc::new(vec![1, 2, 3, 4]);\nlet chromosome = PermutationChromosome::from((4, Arc::clone(&amp;alleles)));\n</code></pre>"},{"location":"source/genome/#genotype","title":"Genotype","text":"<p>The Complete Blueprint</p> <p>The <code>Genotype</code> is a collection of <code>Chromosomes</code> that represent the complete genetic makeup of an individual. A <code>Genotype</code> can be thought of as a \"blueprint\" for an individual that contains all of the genetic information necessary to fully express the traits and characteristics of that individual.  In essance, the <code>Genotype</code> is the \"sentence\" made up of multiple \"words\" (chromosomes). Each <code>Genotype</code> contains one or more <code>Chromosomes</code>, and each <code>Chromosome</code> contains one or more <code>Genes</code>. It is the \"DNA\" of the individual that the <code>GeneticEngine</code> is evolving.</p> <p>Because of the typed nature of the <code>Genotype</code>, it can only hold a collection of the same type of <code>Chromosome</code>. This means that you can have a <code>Genotype</code> that contains only <code>FloatChromosome</code>s, or only <code>IntChromosome</code>s. You cannot have a <code>Genotype</code> that contains both <code>FloatChromosome</code>s and <code>IntChromosome</code>s at the same time - this is by design.</p>  Python Rust <pre><code>import radiate as rd\n\n# Create a genotype with a single FloatChromosome and a 5 FloatGenes\ngenotype = rd.Genotype(\n    rd.chromosome.float(length=5, init_range=(-1.0, 1.0))\n)\n\n# Create a genotype with a single FloatChromosome and a single FloatGene with a \n# randomly generated allele between -1.0 and 1.0\ngenotype = rd.Genotype(\n    rd.Chromosome([rd.gene.float(init_range=(-1.0, 1.0))])\n)\n\n# Create a genotype with multiple chromosomes of lengths 5, 15, and 3\nthree_chromosome_genotype = rd.Genotype([\n    rd.chromosome.float(length=5, init_range=(-1.0, 1.0)),\n    rd.chromosome.float(length=15, init_range=(-1.0, 1.0)),\n    rd.chromosome.float(length=3, init_range=(-1.0, 1.0))\n])\n</code></pre> <pre><code>use radiate::*;\n\n// Create a genotype with a single FloatChromosome and a 5 FloatGenes \nlet genotype = Genotype::from(FloatChromosome::from((5, -1.0..1.0)));\n// -- or --\nlet genotype = Genotype::from(vec![FloatChromosome::new(vec![FloatGene::new(0.1, -1.0..1.0)])]);\n\n// Create a genotype with multiple chromosomes of lengths 5, 15, and 3\nlet three_chromosome_genotype = Genotype::new(vec![\n    FloatChromosome::from((5, -1.0..1.0)),\n    FloatChromosome::from((15, -1.0..1.0)),\n    FloatChromosome::from((3, -1.0..1.0))\n])\n\nlet genotype_length = three_chromosome_genotype.len(); // 3\n\n// Get the second chromosome from the genotype\nlet second_chromosome = three_chromosome_genotype.get(1).unwrap(); // or use `three_chromosome_genotype[1]`\nlet mut second_chromosome_mut = three_chromosome_genotype.get_mut(1).unwrap();\n\nfor chromosome in three_chromosome_genotype.iter() { // or iter_mut()\n    // Do something with each chromosome\n}\n</code></pre>"},{"location":"source/genome/#phenotype","title":"Phenotype","text":"<p>The Living Solution</p> <p>The <code>Phenotype</code> is the representation of an individual in the population that is being evolved by the <code>GeneticEngine</code>. It is a concrete implementation of a <code>Genotype</code> that includes additional functionality for the individual, such as calculating its fitness score. The <code>Phenotype</code> is the \"living\" version of the <code>Genotype</code>, and it is what the <code>GeneticEngine</code> interacts with during the evolution process.</p> <p>The <code>Phenotype</code> is responsible for:</p> <ul> <li>Providing a way for the <code>GeneticEngine</code> to interact with the individual</li> <li>Holding the genetic information of the individual, including its <code>Genotype</code> and fitness or <code>score</code></li> <li>Managing the individual's state during the evolution process</li> </ul> <p>You shouldn't need to create a <code>Phenotype</code> directly, as the <code>GeneticEngine</code> will handle this for you.</p>"},{"location":"source/genome/#population","title":"Population","text":"<p>The Community</p> <p>The <code>Population</code> is a collection of <code>Phenotype</code>s that represent the current state of the genetic algorithm. It is the \"community\" of solutions that the <code>GeneticEngine</code> is evolving. Its really just a vector of <code>Phenotype</code>s. The <code>Population</code> is responsible for:</p> <ul> <li>Sorting individuals based on their fitness scores</li> <li>Holding the current individuals that are being evolved</li> <li>Providing a way for the <code>GeneticEngine</code> to interact with the individuals being evolved</li> </ul> <p>The <code>Population</code> is created and managed by the <code>GeneticEngine</code>, and you shouldn't need to create a <code>Population</code> directly. Instead, you will interact with the <code>GeneticEngine</code> to manage the population and evolve the individuals.</p>"},{"location":"source/genome/#species","title":"Species","text":"<p>The Diverse Groups</p> <p>The <code>Species</code> is an optional component of the genome system that contains a <code>Population</code> of <code>Phenotype</code>s that are similar to each other. It is used to group individuals that are similar in some way, such as having similar <code>Genotype</code> structures or fitness scores. The <code>Species</code> is responsible for:</p> <ul> <li>Grouping individuals that are similar to each other</li> <li>Allowing the <code>GeneticEngine</code> to evolve individuals within a specific group</li> <li>Providing a way to manage diversity within the population</li> <li>Sharing fitness information between individuals in the same species</li> </ul> <p>The <code>Species</code> is not required for the genome system to function, but it can be useful for certain types of problems where grouping similar individuals can help improve the evolution process. For different <code>Species</code> to be created, your <code>GeneticEngine</code> must contain a struct which implements the <code>Diversity</code> trait - this will allow the <code>GeneticEngine</code> to create and manage <code>Species</code> based on the diversity of the individuals in the population. More on this later.</p>"},{"location":"source/genome/#ecosystem_1","title":"Ecosystem","text":"<p>The Environment</p> <p>The <code>Ecosystem</code> is the highest level of the genome system and represents the entire environment in which the genetic algorithm operates. It contains zero to many <code>Species</code>, each with its own <code>Population</code> of <code>Phenotype</code>s, and a single <code>Population</code> containing all <code>Phenotype</code>s. The <code>Ecosystem</code> is responsible for:</p> <ul> <li>Wrapping the entire genetic algorithm environment</li> <li>Managing the overall population of individuals</li> <li>Optionally Coordinating the interactions between different <code>Species</code> and managing their diversity</li> </ul> <p>The <code>Ecosystem</code> is created and managed by the <code>GeneticEngine</code>, and you shouldn't need to create an <code>Ecosystem</code> directly. Instead, you will interact with the <code>GeneticEngine</code> to manage the ecosystem and evolve the individuals within it.</p>"},{"location":"source/genome/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Choose the Right Gene Type:</p> <ul> <li>Use <code>FloatGene</code> for continuous values</li> <li>Use <code>IntGene</code> for discrete values</li> <li>Use <code>BitGene</code> for binary choices</li> <li>Use <code>CharGene</code> for character-based problems</li> <li>Use <code>PermutationGene</code> for ordered sets</li> </ul> </li> <li> <p>Structure Your Chromosomes:</p> <ul> <li>Keep chromosomes focused on specific aspects of your solution</li> <li>Consider using multiple chromosomes for complex problems</li> </ul> </li> <li> <p>Design Your Genotype:</p> <ul> <li>Make sure it can represent all possible solutions</li> <li>Keep it as simple as possible</li> </ul> </li> </ol>"},{"location":"source/genome/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":"<ol> <li> <p>Overly Complex Genotypes:</p> <ul> <li>Don't make your genotype more complex than necessary</li> <li>Start simple and add complexity only when needed</li> </ul> </li> <li> <p>Poor Gene Constraints:</p> <ul> <li>Always set appropriate value ranges and bounds </li> </ul> </li> </ol>"},{"location":"source/genome/#summary","title":"Summary","text":"<p>The genome system in Radiate provides a structured way to represent and manipulate genetic information. By understanding the components of the genome system, you can effectively design and evolve solutions to complex problems using genetic algorithms. The key components include:</p> <ul> <li>Allele: The basic unit of genetic information.</li> <li>Gene: A container for an allele with additional functionality.</li> <li>Chromosome: A collection of genes that represent a part or the whole of the genetic information of an individual.</li> <li>Genotype: A collection of chromosomes that represent the complete genetic makeup of an individual.</li> <li>Phenotype: The representation of an individual in the population that holds additional information like fitness scores.</li> <li>Population: A collection of phenotypes that represent the current group being evolved</li> <li>Species: An optional grouping of similar phenotypes to manage diversity.</li> <li>Ecosystem: The highest level that wraps the entire genetic algorithm environment.</li> </ul>"},{"location":"source/genome/any/","title":"Custom Genes","text":"<p>Although radiate provides a variety of built-in gene types, you can create your own custom genes by subclassing the <code>Gene</code> class. In general, its going to be best to model you're problem domain as closely as possible with the built-in genes, but sometimes you may need a specialized gene type. In rust, this is done by implementing the <code>Gene</code> trait for your custom struct, while in python you can subclass the <code>AnyGene</code> class.</p> <p><code>AnyGene</code> follows how polars handles custom data types by using a generic <code>Any</code> type. This means that you can create genes that hold any type of data you want, as long as its a valid python object.</p> <p>Simply inherit from <code>rd.AnyGene</code> and implement the necessary methods such as <code>__init__</code>, <code>__repr__</code>, and any other methods you may need for your specific use case.</p>  Python <pre><code>import radiate as rd\nfrom datetime import datetime, timezone\n\nrd.random.seed(42)\n\n\nclass ObjectGene(rd.AnyGene):\n    def __init__(self):\n        self.number = rd.random.int(min=0, max=10)\n        self.date = datetime(2020, 1, 1, tzinfo=timezone.utc)\n\n    def __repr__(self):\n        return f\"ObjectGene(number={self.number}, date={self.date})\"\n\ndef fitness_function(phenotypes: list[list[ObjectGene]]) -&gt; list[float]:\n    return [sum(gene.number for gene in individual) for individual in phenotypes]\n\nengine = rd.GeneticEngine(\n    rd.AnyCodec(ObjectGene() for _ in range(10)),\n    fitness_func=rd.BatchFitness(fitness_function),\n    objective=\"min\",\n)\n\nresult = engine.run(rd.ScoreLimit(0), ui=True)\n\nfor obj_gene in result.value():\n    print(obj_gene)\n</code></pre> <p><code>AnyGene</code> is compatible with the rest of the radiate system, meaning alters and other components can work with it seamlessly.</p> <p>Valid alters for <code>AnyGene</code> include:</p> <ul> <li><code>MultiPointCrossover</code></li> <li><code>UniformCrossover</code></li> <li><code>ShuffleCrossover</code></li> <li><code>MeanCrossover</code></li> <li><code>SwapMutator</code></li> <li><code>ScrambleMutator</code></li> <li><code>InversionMutator</code></li> <li><code>UniformMutator</code></li> <li><code>ArithmeticMutator</code></li> </ul> <p>Converting between rust and python custom genes behind the scenes is a bit more involved that other genes, so reach for built-in genes when possible for best performance.</p>"},{"location":"source/genome/codec/","title":"Codecs","text":""},{"location":"source/genome/codec/#what-is-a-codec","title":"What is a Codec?","text":"<p>Radiate's <code>GeneticEngine</code> operates on an abstract representation of your domain problem using the 'Genome'. To bridge the gap between your domain and radiate's, we use a <code>Codec</code> - encoder-decoder. A <code>Codec</code> is a mechanism that encodes and decodes genetic information between the 'problem space' (your domain) and the 'solution space' (Radiate's internal representation).</p> <p>Essentially, this is a component that defines how genetic information is structured and represented in your evolutionary algorithm. Think of it as a blueprint that tells the algorithm:</p> <ul> <li>What type of data you're evolving (numbers, characters, etc.)</li> <li>How that data is organized (single values, arrays, matrices, etc.)</li> <li>Any other chromosome or gene level information needed for the algorithm to work effectively.</li> </ul>"},{"location":"source/genome/codec/#why-do-we-need-codecs","title":"Why Do We Need Codecs?","text":"<p>In genetic algorithms, we need to represent potential solutions to our problem in a way that can be:</p> <ol> <li>Evolved: Modified through operations like mutation and crossover</li> <li>Evaluated: Tested to see how good the solution is</li> <li>Consistent: Able to be encoded to chromosomes and genes which the engine can understand and operate on, then decoded back into a format that can be used in the real-world problem (e.g., your fitness function).</li> </ol> <p>For example, if you're evolving neural network weights, you need to:</p> <ul> <li>Represent the weights as numbers</li> <li>Organize them in the correct structure (matrices for layers)</li> <li>Keep them within reasonable ranges (e.g., between -1 and 1)</li> </ul> <p>See this example for a simple neural network evolution using a custom codec.</p>"},{"location":"source/genome/codec/#how-codecs-fit-into-the-genetic-algorithm","title":"How Codecs Fit Into the Genetic Algorithm","text":"<p>Here's a simple breakdown of how codecs work in the evolution process:</p> <ol> <li>Initialization: When you create a population, the codec defines how each individual's genetic information is structured and created within the population. For example, if you're evolving a list of floating-point numbers, the codec will specify how many numbers, their ranges, and how they are represented.</li> <li>Evaluation: Your fitness function receives the decoded values in a format you can work with and have possibly defined.</li> </ol>"},{"location":"source/genome/codec/#types-of-codecs","title":"Types of Codecs","text":"<p>Radiate provides several codec types out of the box that should be able to cover most use cases. Each codec type is designed to handle specific data types and structures, making it easier to evolve solutions for various problems. The core codecs include:</p> FloatCodec <p>Use this when you need to evolve floating-point numbers. Perfect for:</p> <ul> <li>Neural network weights</li> <li>Mathematical function parameters</li> <li>Continuous optimization problems</li> <li>Real-valued parameters</li> </ul> <p>In all <code>FloatCodec</code> varients, the <code>bounds</code> is optional and defaults to the <code>init_range</code> if not specified.</p>  Python Rust <pre><code>import radiate as rd\n\n# For a single parameter\ncodec = rd.FloatCodec.scalar(init_range=(0.0, 1.0), bounds=(-10.0, 10.0))\n\n# For a list of parameters\ncodec = rd.FloatCodec.vector(length=5, init_range=(-1.0, 1.0), bounds=(-10.0, 10.0))\n\n# For a matrix of parameters (like neural network weights)\ncodec = rd.FloatCodec.matrix(shape=(3, 2), init_range=(-0.1, 0.1), bounds=(-1.0, 1.0))\n# -- or --\n# supply a list of shapes for jagged matrices e.g. matrix with three rows (chromosomes) and two columns (genes)\ncodec = rd.FloatCodec.matrix([2, 2, 2], init_range=(-0.1, 0.1), bounds=(-1.0, 1.0))\n</code></pre> <p>Every <code>FloatCodec</code> will <code>encode()</code> a <code>Genotype&lt;FloatChromosome&gt;</code>.</p> <pre><code>use radiate::*;\n\n// single float parameter\nlet codec_scalar = FloatCodec::scalar(-1.0..1.0).with_bounds(-10.0..10.0); \nlet encoded_scalar: Genotype&lt;FloatChromosome&gt; = codec_scalar.encode();\nlet decoded_scalar: f32 = codec_scalar.decode(&amp;encoded_scalar);     \n\n// vector of 5 floats\nlet codec_vector = FloatCodec::vector(5, -1.0..1.0).with_bounds(-10.0..10.0);   \nlet encoded_vector: Genotype&lt;FloatChromosome&gt; = codec_vector.encode();\nlet decoded_vector: Vec&lt;f32&gt; = codec_vector.decode(&amp;encoded_vector);\n\n// 3x2 matrix of floats\nlet codec_matrix = FloatCodec::matrix(3, 2, -0.1..0.1).with_bounds(-1.0..1.0);  \nlet encoded_matrix: Genotype&lt;FloatChromosome&gt; = codec_matrix.encode();\nlet decoded_matrix: Vec&lt;Vec&lt;f32&gt;&gt; = codec_matrix.decode(&amp;encoded_matrix);\n</code></pre> IntCodec <p>Use this when you need to evolve integer values. Good for:</p> <ul> <li>Discrete optimization problems</li> <li>Array indices</li> <li>Configuration parameters that must be whole numbers</li> </ul> <p>In all <code>IntCodec</code> varients, the <code>bounds</code> is optional and defaults to the <code>init_range</code> if not specified.</p>  Python Rust <pre><code>import radiate as rd\n\n# For a single parameter\ncodec = rd.IntCodec.scalar(init_range=(0, 1), bounds=(-10, 10))\n\n# For a list of parameters\ncodec = rd.IntCodec.vector(length=5, init_range=(-1, 1), bounds=(-10, 10))\n\n# For a matrix of ints\ncodec = rd.IntCodec.matrix(shape=(3, 2), init_range=(-1, 1), bounds=(-10, 10))\n# -- or --\n# supply a list of shapes for jagged matrices e.g. matrix with three rows (chromosomes) and two columns (genes)\ncodec = rd.IntCodec.matrix([2, 2, 2], init_range=(-1, 1), bounds=(-10, 10))\n</code></pre> <p>The type of int can be specified as <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code> or <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code> depending on your needs. Every <code>IntCodec&lt;I&gt;</code> will <code>encode()</code> a <code>Genotype&lt;IntChromosome&lt;I&gt;&gt;</code>.</p> <pre><code>use radiate::*;\n\n// single float parameter\nlet codec_scalar = IntCodec::scalar(-1..1).with_bounds(-10..10);\nlet encoded_scalar: Genotype&lt;IntChromosome&lt;i32&gt;&gt; = codec_scalar.encode();\nlet decoded_scalar: i32 = codec_scalar.decode(&amp;encoded_scalar);\n\n// vector of 5 floats - specify the int type\nlet codec_vector = IntCodec::&lt;i128&gt;::vector(5, -1..1).with_bounds(-10..10);\nlet encoded_vector: Genotype&lt;IntChromosome&lt;i128&gt;&gt; = codec_vector.encode();\nlet decoded_vector: Vec&lt;i128&gt; = codec_vector.decode(&amp;encoded_vector);\n\n// 3x2 matrix of floats\nlet codec_matrix = IntCodec::matrix(3, 2, -1..1).with_bounds(-10..10);\nlet encoded_matrix: Genotype&lt;IntChromosome&lt;i32&gt;&gt; = codec_matrix.encode();\nlet decoded_matrix: Vec&lt;Vec&lt;i32&gt;&gt; = codec_matrix.decode(&amp;encoded_matrix);\n</code></pre> CharCodec <p>Use this when you need to evolve character strings. Useful for:</p> <ul> <li>Text generation</li> <li>String-based problems</li> </ul> <p>There is an optional <code>char_set</code> parameter that allows you to specify the set of characters to use for encoding. If not specified, it defaults to lowercase letters (a-z), uppercase letters (A-Z), digits (0-9), and common punctuation ( !\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~).</p>  Python Rust <pre><code>import radiate as rd\n\n# For a list of parameters\ncodec = rd.CharCodec.vector(length=5, char_set='abcdefghijklmnopqrstuvwxyz')\n\n# For a matrix of chars\ncodec = rd.CharCodec.matrix(shape=(3, 2), char_set={'a', 'b', 'c', 'd'})\n# -- or --\n# supply a list of shapes for jagged matrices e.g. matrix with three rows (chromosomes) and two columns (genes) - use the default char_set\ncodec = rd.CharCodec.matrix([2, 2, 2])\n</code></pre> <p>Every <code>CharCodec</code> will <code>encode()</code> a <code>Genotype&lt;CharChromosome&gt;</code>.</p> <pre><code>use radiate::*;\n\n// vector of 5 chars - specify the char set\nlet codec_vector = CharCodec::vector(5).with_char_set(\"abcdefghijklmnopqrstuvwxyz\");\nlet encoded_vector: Genotype&lt;CharChromosome&gt; = codec_vector.encode();\nlet decoded_vector: Vec&lt;char&gt; = codec_vector.decode(&amp;encoded_vector);\n\n// 3x2 matrix of chars\nlet codec_matrix = CharCodec::matrix(3, 2);\nlet encoded_matrix: Genotype&lt;CharChromosome&gt; = codec_matrix.encode();\nlet decoded_matrix: Vec&lt;Vec&lt;char&gt;&gt; = codec_matrix.decode(&amp;encoded_matrix);\n</code></pre> BitCodec <p>Use this when you need to evolve binary data. Each <code>Gene</code> is a <code>BitGene</code> where the <code>Allele</code>, or value being evolved, is a bool. Ideal for:</p> <ul> <li>Binary optimization problems</li> <li>Feature selection</li> <li>Boolean configurations</li> <li>Subset selection problems (e.g., Knapsack problem)</li> </ul> <p>There is no <code>scalar</code> varient of the <code>BitCodec</code> because...that doesn't seem useful at all.</p>  Python Rust <pre><code>import radiate as rd\n\n# For a list of parameters\ncodec = rd.BitCodec.vector(5)\n\n# For a matrix of bools\ncodec = rd.BitCodec.matrix(shape=(3, 2))\n# -- or --\n# supply a list of shapes for jagged matrices e.g. matrix with three rows (chromosomes) and two columns (genes)\ncodec = rd.BitCodec.matrix([2, 2, 2])\n</code></pre> <p>Every <code>BitCodec</code> will <code>encode()</code> a <code>Genotype&lt;BitChromosome&gt;</code>.</p> <pre><code>use radiate::*;\n\n// vector of 5 bools\nlet codec_vector = BitCodec::vector(5);\nlet encoded_vector: Genotype&lt;BitChromosome&gt; = codec_vector.encode();\nlet decoded_vector: Vec&lt;bool&gt; = codec_vector.decode(&amp;encoded_vector);\n\n// 3x2 matrix of bools\nlet codec_matrix = BitCodec::matrix(3, 2);\nlet encoded_matrix: Genotype&lt;BitChromosome&gt; = codec_matrix.encode();\nlet decoded_matrix: Vec&lt;Vec&lt;bool&gt;&gt; = codec_matrix.decode(&amp;encoded_matrix);\n</code></pre> SubSetCodec <p>For when you need to optimize a subset or smaller collection from a larger set. Underneath the hood, the <code>SubSetCodec</code> uses a <code>BitCodec</code> to represent the selection of items. This codec allows you to evolve a selection of items from a larger pool, where each gene represents whether an item is included (1) or excluded (0) in the subset.</p> <ul> <li>Feature selection in machine learning</li> <li>Knapsack problem</li> <li>Combinatorial optimization</li> </ul>  Python Rust <p> Under Construction </p> <p>This codec is currently under construction and not yet available in the Python API.</p> <p>Each <code>SubSetCodec</code> will <code>encode()</code> a <code>Genotype&lt;BitChromosome&gt;</code> and <code>decode()</code> to a <code>Vec&lt;Arc&lt;T&gt;&gt;</code> of the selected items,  where a selected item is \"selected\" if the corresponding gene in the <code>BitChromosome</code> is <code>true</code>.</p> <pre><code>use radiate::*;\n\n#[derive(Debug, Clone)]\npub struct Item {\n    pub weight: f32,\n    pub value: f32,\n}\n\nlet items = vec![\n    Item { weight: 2.0, value: 3.0 },\n    Item { weight: 3.0, value: 4.0 },\n    Item { weight: 4.0, value: 5.0 },\n    Item { weight: 5.0, value: 6.0 },\n    Item { weight: 6.0, value: 7.0 },\n    Item { weight: 7.0, value: 8.0 },\n    Item { weight: 8.0, value: 9.0 },\n    Item { weight: 9.0, value: 10.0 },\n];\n\nlet subset_codec = SubSetCodec::vector(items);\n\nlet genotype: Genotype&lt;BitChromosome&gt; = subset_codec.encode();\nlet decoded: Vec&lt;Arc&lt;Item&gt;&gt; = subset_codec.decode(&amp;genotype);\n</code></pre> PermutationCodec <p>The <code>PermutationCodec&lt;T&gt;</code> ensures that each gene in the chromosome is a unique item from the set. Use this when you need to evolve permutations of a set of items. This codec is particularly useful for problems where the order of items matters, such as:</p> <ul> <li>Traveling Salesman Problem (TSP)</li> <li>Job scheduling</li> <li>Sequence alignment</li> </ul>  Python Rust <pre><code>import radiate as rd\n\n# For a list of unique items\ncodec = rd.PermutationCodec(alleles=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n# This will produce a Genotype&lt;PermutationChromosome&gt; with 1 PermutationChromosome which\n# holds 10 unique genes (0-9) in a random order.\ngenotype = codec.encode()\n# Decode to a list of unique items\ndecoded = codec.decode(genotype)\n# decoded will be a list of unique items from the original alleles.\n# e.g. [3, 0, 7, 1, 9, 2, 5, 6, 4, 8]\n# Note: The order of the decoded items will be the same as the order of the\n# genes in the PermutationChromosome, which is a random permutation of the original alleles.\n</code></pre> <p>Every <code>PermutationCodec&lt;T&gt;</code> will <code>encode()</code> a <code>Genotype&lt;PermutationChromosome&lt;T&gt;&gt;</code> and <code>decode()</code> to a <code>Vec&lt;T&gt;</code> where each <code>T</code> is a unique item from the given set of <code>allele</code>s.</p> <pre><code>use radiate::*;\n\nlet codec: PermutationCodec&lt;usize&gt; = PermutationCodec::new((0..10).collect());\n\n// Encode a genotype of Genotype&lt;PermutationChromosome&gt; and decode to a Vec&lt;usize&gt; where each usize is a unique index\n// from the original value_range.\n// This will ensure that the permutation is valid and does not contain duplicates.\nlet genotype: Genotype&lt;PermutationChromosome&lt;usize&gt;&gt; = codec.encode();\nlet decoded: Vec&lt;usize&gt; = codec.decode(&amp;genotype);\n</code></pre> FnCodec <p>The <code>FnCodec</code> is a flexible codec that allows you to define custom encoding and decoding functions for your problem. This is particularly useful when your solution space does not fit neatly into the other codec types or when you need to handle complex data structures. It allows you to specify how to encode and decode your genetic information using user-defined functions. This codec is ideal for:</p> <ul> <li>Complex data structures that don't fit into standard codecs</li> <li>Custom encoding/decoding logic</li> <li>Problems where the representation is not easily defined by simple types</li> </ul>  Python Rust <p> Under Construction </p> <p>This codec is currently under construction and not yet available in the Python API.</p> <p>Each <code>FnCodec&lt;I, O&gt;</code> will <code>encode()</code> a <code>Genotype&lt;C&gt;</code> where <code>C</code> is the <code>chromosome</code> that you choose and <code>decode()</code> to an <code>O</code>. In the below case, the type <code>C</code> is an <code>IntChromosome&lt;i8&gt;</code> and <code>O</code> is the output type (e.g., <code>NQueens</code>).</p> <pre><code>use radiate::*;\n\n// A simple struct to represent the NQueens problem - this struct will be the input to your fitness function.\nconst N_QUEENS: usize = 8;\n\n#[derive(Clone, Debug, PartialEq)]\nstruct NQueens(Vec&lt;i8&gt;);\n\n// this is a simple example of the NQueens problem.\n// The resulting codec type will be FnCodec&lt;IntChromosome&lt;i8&gt;, NQueens&gt;.\nlet codec: FnCodec&lt;IntChromosome&lt;i8&gt;, NQueens&gt; = FnCodec::new()\n    .with_encoder(|| {\n        Genotype::new(vec![IntChromosome::new((0..N_QUEENS)\n                .map(|_| IntGene::from(0..N_QUEENS as i8))\n                .collect(),\n        )])\n    })\n    .with_decoder(|genotype| {\n        NQueens(genotype[0]\n            .genes()\n            .iter()\n            .map(|g| *g.allele())\n            .collect::&lt;Vec&lt;i8&gt;&gt;())\n    });\n\n// encode and decode\nlet genotype: Genotype&lt;IntChromosome&lt;i8&gt;&gt; = codec.encode();\nlet decoded: NQueens = codec.decode(&amp;genotype);\n</code></pre>"},{"location":"source/genome/codec/#best-practices","title":"Best Practices","text":"<ol> <li>Start Simple: Begin with a simple codec structure and expand as needed</li> <li>Choose Appropriate Ranges (IntCodec &amp; FloatCodec):<ul> <li><code>value_range</code>/<code>init_range</code>: Set this to reasonable initial values</li> <li><code>bound_range</code>/<code>bounds</code>: Set this to the valid range for your problem</li> </ul> </li> <li>Match Your Problem: Choose the codec type that best represents your solution space</li> <li>Consider Structure: Use the appropriate configuration (scalar/vector/matrix) for your problem</li> </ol>"},{"location":"source/genome/codec/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":"<ol> <li>Too Wide Ranges: Starting with very wide value ranges can make evolution slower</li> <li>Too Narrow Bounds: Restrictive bound ranges might prevent finding optimal solutions</li> <li>Mismatched Structure: Using the wrong codec structure can make it impossible to represent valid solutions</li> </ol>"},{"location":"source/genome/example/","title":"Example","text":"<p>Let's look at a basic example of how to use the <code>Codec</code> for evolving a simple function: finding the best values for <code>y = ax + b</code> where we want to find optimal values for <code>a</code> and <code>b</code>.</p>  Python Rust <p>Python also allows you to pass a flag to most codecs to specify if you want a <code>numpy.array</code> or a <code>list</code> to be returned when decoding. You can do this by passing <code>use_numpy=True</code> to the codec constructor. </p> <p>E.g. <code>rd.FloatCodec.vector(length=2, init_range=(-1.0, 1.0), bound_range=(-10.0, 10.0), use_numpy=True)</code> will return a <code>numpy.array</code> when decoding. You can also just write the decoded value in your <code>fitnesss_func</code> in a <code>numpy.arry(my_decoded_value)</code> format to get a <code>numpy.array</code> back. The performance difference between the two is negligible, so you can choose the one that best fits your needs.</p> <pre><code>import radiate as rd\n\n# Define a fitness function that uses the decoded values\ndef fitness_function(individual: list[float]) -&gt; float:    \n    # Calculate how well these parameters fit your data\n    a = individual[0]\n    b = individual[1]\n    return calculate_error(a, b)  # Your error calculation here\n\n# Create a codec for two parameters (a and b)\ncodec = rd.FloatCodec.vector(\n    length=2,                   # We need two parameters: a and b\n    init_range=(-1.0, 1.0),    # Start with values between -1 and 1\n    bounds=(-10.0, 10.0)       # Allow evolution to modify the values between -10 and 10\n)\n\n# Create the evolution engine\nengine = rd.GeneticEngine(\n    codec=codec,\n    fitness_func=fitness_function,\n    # ... other parameters ...\n)\n\n# Run the engine\nresult = engine.run([rd.ScoreLimit(0.01), rd.GenerationsLimit(1000)])\n</code></pre> <pre><code>use radiate::*;\n\n// Define a fitness function that uses the decoded values\nfn fitness_fn(individual: Vec&lt;f32&gt;) -&gt; f32 {\n    let a = individual[0];\n    let b = individual[1];\n    calculate_error(a, b)  // Your error calculation here\n}\n\n// This will produce a Genotype&lt;FloatChromosome&gt; with 1 FloatChromosome which\n// holds 2 FloatGenes (a and b), each with a value between -1.0 and 1.0 and a bound between -10.0 and 10.0\nlet codec = FloatCodec::vector(2, -1.0..1.0).with_bounds(-10.0..10.0);\n\nlet mut engine = GeneticEngine::builder()\n    .codec(codec)\n    .fitness_fn(fitness_fn)\n    // ... other parameters ...\n    .build();\n\n// Run the engine\nlet result = engine.run(|generation| {\n    generation.index() &gt;= 1000 || generation.score().as_f32() &lt;= 0.01\n});\n</code></pre> <p>Some chromosomes are able to be used directly as codecs aswell. This means that you could create  engines using methods as seen below. For the duration of the user guide however, we'll use the above method.</p> <pre><code>// This is the same as using a FloatCodec::vector(2, -1.0..1.0).with_bounds(-10.0..10.0);\nlet mut engine = GeneticEngine::builder()\n    .codec(FloatChromosome::from((2, -1.0..1.0, -10..10)))\n    .fitness_fn(fitness_fn)\n    // ... other parameters ...\n    .build()\n\n// To create a matrix codec using a Chromosome just use a Vec\nlet mut engine = GeneticEngine::builder()\n    .codec(vec![\n        FloatChromosome::from((2, -1.0..1.0, -10..10)),\n        FloatChromosome::from(vec![\n            FloatGene::from(-3.0..3.0),\n            FloatGene::from((-5.0..5.0, -10.0..10.0))\n        ])\n    ])\n    .fitness_fn(|phenotype: Vec&lt;Vec&lt;f32&gt;&gt;| {\n        // ... your fitness calc ...\n    })\n    // ... other parameters ...\n    .build()\n</code></pre>"},{"location":"source/gp/","title":"Genetic Programming","text":"<p> Under Construction </p> <p>As of <code>01/15/2026</code>: These docs are a work in progress and may not be complete or fully accurate. Please check back later for updates.</p> <p>Genetic Programming (GP) in Radiate enables the evolution of programs represented as expression trees and computational graphs. This powerful feature allows you to solve complex problems by evolving mathematical expressions, decision trees, neural network topologies, and more.</p> <p>Radiate's GP implementation provides two core data structures: Trees for hierarchical expressions and Graphs for complex computational networks. Each offers unique capabilities for different problem domains. Both the <code>tree</code> and <code>graph</code> modules come with their own specific chromosomes, codecs and alters to evolve these structures effectively.</p>"},{"location":"source/gp/#installation","title":"Installation","text":"<p>To use Radiate's Genetic Programming features, you need to install the library with the appropriate feature flags.</p>  Python Rust <pre><code>pip install radiate\n</code></pre> <pre><code>cargo add radiate -F gp\n\n# Or Cargo.toml\n[dependencies]\nradiate = { version = \"x\", features = [\"gp\", ...] }\n</code></pre>"},{"location":"source/gp/#arity","title":"Arity","text":"<p>Arity is the cornerstone concept behind how <code>nodes</code> and <code>ops</code> function within Radiate's genetic programming system. Arity is a term used to describe the number of arguments or inputs a function takes. In the context of genetic programming, arity defines how many inputs a <code>node</code> or an <code>op</code> can accept in both <code>trees</code> and <code>graphs</code>. For <code>graphs</code> <code>arity</code> is used to determine how many incoming connections a <code>GraphNode</code> can have, while for <code>trees</code> it determines how many children a <code>TreeNode</code> can have. Radiate uses an enum to express <code>arity</code> defined in three variants:</p> <ol> <li>Zero: The operation takes no inputs (e.g., constants).</li> <li>Exact(usize): The operation takes a specific number of inputs.</li> <li>Any: The operation can take any number of inputs (e.g., functions like sum or product).</li> </ol> <p>In most cases, the <code>tree</code> or <code>graph</code> will try it's best ensure that their node's <code>arity</code> is not violated, but it will ultimately be up to the user to ensure that the <code>arity</code> is correct.</p>"},{"location":"source/gp/graph/","title":"Graphs","text":"<p>Graphs are a powerful way to represent problems. They are used in many fields, such as Neural Networks, and can be used to solve complex problems. Radiate thinks of graphs in a more general way than most implementations. Instead of being a collection of inputs, nodes, edges, and outputs, radiate thinks of a graph as simply a bag of nodes that can be connected in any way. Why? Well, because it allows for more flexibility within the graph and it lends itself well to the evolutionary nature of genetic programming. However, this representation is not without it's drawbacks. It can be difficult to reason about the graph and it can be difficult to ensure that the graph is valid. Radiate tries to mitigate these issues by sticking to a few simple rules that govern the graph.</p> <ol> <li>Each input node must have 0 incoming connections and at least 1 outgoing connection.</li> <li>Each output node must have at least 1 incoming connection and 0 outgoing connections.</li> <li>Each edge node must have exactly 1 incoming connection and 1 outgoing connection.</li> <li>Each vertex node must have at least 1 incoming connection and at least 1 outgoing connection.</li> </ol> <p>With these rules in mind, we can begin to build and evolve graphs. The graph typically relies on an underlying <code>GraphArchitect</code> to construct a valid graph. This architect is a builder pattern that keeps an aggregate of nodes added and their relationships to other nodes. Because of the architect's decoupled nature, we can easily create complex graphs. When combined with the op functionality, the <code>graph</code> module allows for the creation of complex computational graphs that can be evolved to solve or eval regression problems. </p> <p>Radiate provides a few basic graph architectures, but it is also possible to construct your own graph through either the built in graph functions or by using the architect. In most cases building a graph requires a vec of tuples (or a <code>NodeStore</code>) where the first element is the <code>NodeType</code> and the second element is a vec of values that the <code>GraphNode</code> can take. The <code>NodeType</code> is either <code>Input</code>, <code>Output</code>, <code>Vertex</code>, or <code>Edge</code>. The value of the <code>GraphNode</code> is picked at random from the vec of it's <code>NodeType</code>.</p> <p>Key Properties:</p> <ul> <li>Flexible Connections: Nodes can have multiple inputs/outputs</li> <li>Indexed Access: Each node has a unique index in the vector</li> <li>Connection Sets: Each node maintains incoming/outgoing connections</li> <li>Direction Support: Can be directed acyclic (DAG) or cyclic</li> </ul>"},{"location":"source/gp/graph/#building-a-graph","title":"Building a Graph","text":"Python Rust <p>Creating a graph in python doesn't offer as much flexibility as in rust at the current time, but it can still be done through the codec.</p> <pre><code>import radiate as rd\n\ncodec = rd.GraphCodec.directed(\n    shape=(2, 1),\n    vertex=[rd.Op.add(), rd.Op.sub(), rd.Op.mul(), rd.Op.div()],\n    edge=rd.Op.weight(), # or [rd.Op.weight(), ...]\n    output=rd.Op.linear(), # or [rd.Op.linear(), ...]\n)\n\ngraph = codec.decode(codec.encode())\n\ninputs = [[1.0, 2.0]]\noutputs = graph.eval(inputs)\n</code></pre> <pre><code>use radiate::*;\n\n// create a simple graph:\n// 0 -&gt; 1 -&gt; 2\nlet mut graph = Graph::&lt;i32&gt;::default();\n\nlet idx_one = graph.insert(NodeType::Input, 0);\nlet idx_two = graph.insert(NodeType::Vertex, 1);\nlet idx_three = graph.insert(NodeType::Output, 2);\n\ngraph.attach(idx_one, idx_two).attach(idx_two, idx_three);\n\n// Set cycles in a cyclic graph:\nlet mut graph = Graph::&lt;i32&gt;::default();\n\nlet idx_one = graph.insert(NodeType::Input, 0);\nlet idx_two = graph.insert(NodeType::Vertex, 1);\nlet idx_three = graph.insert(NodeType::Vertex, 2);\nlet idx_four = graph.insert(NodeType::Output, 3);\n\ngraph\n    .attach(idx_one, idx_two)\n    .attach(idx_two, idx_three)\n    .attach(idx_three, idx_two)\n    .attach(idx_three, idx_four)\n    .attach(idx_four, idx_two);\n\ngraph.set_cycles(vec![]);\n</code></pre> <p>Now, the above works just fine, but can become cumbersome quickly. To ease the process of creating a <code>graph</code>, we can use the default <code>graph</code> types to create graphs in a better way. All we need to do is define a <code>NodeStore</code> that contains the possible values for each node given a <code>NodeType</code>. </p>  Python Rust <p>There isn't a direct way to create a Graph in python, instead we can use the codec to create on directly if needed.</p> <pre><code>import radiate as rd\n\ncodec = rd.GraphCodec.directed(\n    shape=(2, 1),\n    vertex=[rd.Op.add(), rd.Op.sub(), rd.Op.mul(), rd.Op.div()],\n    edge=[rd.Op.weight()],\n    output=[rd.Op.linear()],\n)\n\n# or recurrent graph\ncodec = rd.GraphCodec.recurrent(\n    # ... same as above\n)\n\n# or weighted directed graph\ncodec = rd.GraphCodec.weighted_directed(\n    # ... same as above\n)\n\n# or weighted recurrent graph\ncodec = rd.GraphCodec.weighted_recurrent(\n    # ... same as above\n)\n\n# or lstm graph\ncodec = rd.GraphCodec.lstm(\n    # ... same as above\n)\n\n# or gru graph\ncodec = rd.GraphCodec.gru(\n    # ... same as above\n)\n\ngraph = codec.decode(codec.encode())\n\ninputs = [[1.0, 2.0]]\noutputs = graph.eval(inputs)\n</code></pre> <pre><code>use radiate::*;\n\n// Input nodes are picked in order while the rest of the node's values\n// are picked at random.\n\n// Take note that the NodeType::Input has two variables, [0, 1] \n// and we create a graph with two input nodes.\nlet values = vec![\n    (NodeType::Input, vec![Op::var(0), Op::var(1)]),\n    (NodeType::Edge, vec![Op::weight()]),\n    (NodeType::Vertex, vec![Op::sub(), Op::mul(), Op::linear()]),\n    (NodeType::Output, vec![Op::linear()]),\n];\n\n// create a directed graph with 2 input nodes and 2 output nodes\nlet graph: Graph&lt;Op&lt;f32&gt;&gt; = Graph::directed(2, 2, values);\n\n// create a recurrent graph with 2 input nodes and 2 output nodes\nlet graph: Graph&lt;Op&lt;f32&gt;&gt; = Graph::recurrent(2, 2, values);\n\n// create a weighted directed graph with 2 input nodes and 2 output nodes\nlet graph: Graph&lt;Op&lt;f32&gt;&gt; = Graph::weighted_directed(2, 2, values);\n\n// create a weighted recurrent graph with 2 input nodes and 2 output nodes\nlet graph: Graph&lt;Op&lt;f32&gt;&gt; = Graph::weighted_recurrent(2, 2, values);\n\n// create an LSTM graph with 2 input nodes and 2 output nodes\nlet graph: Graph&lt;Op&lt;f32&gt;&gt; = Graph::lstm(2, 2, values);\n\n// create a GRU graph with 2 input nodes and 2 output nodes\nlet graph: Graph&lt;Op&lt;f32&gt;&gt; = Graph::gru(2, 2, values);\n\n// Op graphs can be evaluated much like trees, but with the added complexity of connections.\nlet inputs = vec![vec![1.0, 2.0]];\nlet outputs = graph.eval(&amp;inputs);\n</code></pre> <p>The <code>Graph</code> can be visualized using the <code>dot</code> format, which can be rendered using tools like Graphviz. This is especially useful for understanding the structure of complex graphs. Calling <code>.to_dot()</code> on a graph will generate the dot representation. The dot format for graphs can be intpreted as follows:</p> <ul> <li>Blue squares represent input nodes</li> <li>Yellow circles represent vertex nodes</li> <li>Green squares represent output nodes.</li> <li>Grey diamonds represent edge nodes.</li> <li>Solid lines represent directed connections</li> <li>Dashed lines represent recurrent connections or connections that come from cycles.</li> </ul> Directed <p>A directed graph is a graph in which the edges have a direction. This means that the connections between nodes are one-way, and data can only flow in the direction of the edges. Here we can see a simple directed graph with 2 input nodes and 1 output node.</p> <p> </p> Recurrent <p>A recurrent graph is a graph in which the edges can form cycles. This means that data can flow in loops, allowing for more complex behaviors. Here we can see a simple recurrent graph with 2 input nodes, two recurrent vertex nodes, and 1 output node.</p> <p> </p> Weighted Directed <p>A weighted directed graph is a directed graph in which the edges have weights. These weights can represent the strength or importance of the connection between nodes. Here we can see a simple weighted directed graph with 2 input nodes, 2 weighted edge nodes, and 1 output node.</p> <p> </p> Weighted Recurrent <p>A weighted recurrent graph is a recurrent graph in which the edges have weights. These weights can represent the strength or importance of the connection between nodes. Here we can see a simple weighted recurrent graph with 2 input nodes, 2 recurrent vertex nodes, 2 weighted edge nodes, and 1 output node.</p> <p> </p> Lstm <p>A Long Short-Term Memory (LSTM) network is a type of recurrent neural network that is designed to handle sequential data. It is capable of learning long-term dependencies and is often used in tasks such as language modeling and time series prediction. Here we can see a simple LSTM with 2 input node and 2 output node. The internal nodes are generated randomly from the provided store. This is an intentionally simplified LSTM structure with the intent of the rest of the nodes being evolved.</p> <p> </p> Gru <p>A Gated Recurrent Unit (GRU) is a type of recurrent neural network that is designed to handle sequential data. It is similar to a Long Short-Term Memory (LSTM) network, but it has a simpler architecture and is easier to train. Here we can see a simple GRU with 1 input node and 1 output node. The internal nodes are generated randomly from the provided store. This is an intentionally simplified GRU structure with the intent of the rest of the nodes being evolved.</p> <p> </p>"},{"location":"source/gp/graph/#node","title":"Node","text":"<p>The <code>GraphNode</code> struct is a fundamental building block for graph-based genetic programming in Radiate. It represents a node in a directed graph that can have both incoming and outgoing connections to other nodes. Each node has a unique identifier, an index in the graph, a value of type T, and maintains sets of incoming and outgoing connections. The <code>GraphNode</code> can be of different types, such as <code>Input</code>, <code>Output</code>, <code>Vertex</code>, or <code>Edge</code>, each serving a specific role in the graph structure. To ensure the integrity of the graph, the <code>GraphNode</code> enforces rules based on its type, such as the number of incoming and outgoing connections it can have. In order to facilitate genetic programming, the <code>GraphNode</code> implements the <code>Gene</code> trait, where it's <code>allele</code> is the value of the node, and its <code>gene</code> is the node itself. </p> <p>Node Types:</p> <ul> <li>Input: Entry points (no incoming, one or more outgoing)</li> <li>Output: Exit points (one or more incoming, no outgoing)</li> <li>Vertex: Internal computation (both incoming and outgoing)</li> <li>Edge: Connection nodes (exactly one incoming and one outgoing)</li> </ul>  Python Rust <p>There is no <code>GraphNode</code> in python. It isn't necessary for the api. </p> <pre><code>use radiate::*;\n\n// Create a new input node with value 42\nlet node = GraphNode::new(0, NodeType::Input, 42);\n\n// Create a node with specific arity\n// This node will be invalid if it has a number of incoming connections other than 2\nlet node_with_arity = GraphNode::with_arity(1, NodeType::Vertex, 42, Arity::Exact(2));\n</code></pre>"},{"location":"source/gp/graph/#codec","title":"Codec","text":"<p>The <code>GraphCodec</code> is a codec that encodes a <code>GraphChromosome</code> and decodes it back into a <code>Graph</code>. The <code>GraphCodec</code> can be configured to create directed or recurrent graphs.</p>  Python Rust <pre><code>import radiate as rd\n\n# Create a directed graph codec \ncodec = rd.GraphCodec.directed(\n    shape=(2, 1),\n    vertex=[rd.Op.add(), rd.Op.mul()],\n    edge=rd.Op.weight(),\n    output=rd.Op.linear()\n)\n\ngenotype = codec.encode()\ngraph = codec.decode(genotype)\n\n# Create a recurrent graph codec\ncodec = rd.GraphCodec.recurrent(\n    shape=(2, 1),\n    vertex=[rd.Op.add(), rd.Op.mul()],\n    edge=rd.Op.weight(),\n    output=rd.Op.linear()\n)\n\ngenotype = codec.encode()\nrecurrent_graph = codec.decode(genotype)\n</code></pre> <pre><code>use radiate::*;\n\n// Create a store for graph operations\nlet store = vec![\n    (NodeType::Input, vec![Op::var(0), Op::var(1)]),\n    (NodeType::Edge, vec![Op::add(), Op::mul()]),\n    (NodeType::Vertex, vec![Op::sub(), Op::div()]),\n    (NodeType::Output, vec![Op::sigmoid(), Op::tanh()]),\n];\n\n// Create a directed graph codec with 2 input nodes and 2 output nodes\nlet codec = GraphCodec::directed(2, 2, store);\nlet genotype: Genotype&lt;GraphChromosome&lt;Op&lt;f32&gt;&gt;&gt; = codec.encode();\nlet graph: Graph&lt;Op&lt;f32&gt;&gt; = codec.decode(&amp;genotype);\n\n// Create a recurrent graph codec with 2 input nodes and 2 output nodes\nlet recurrent_codec = GraphCodec::recurrent(2, 2, store);\nlet recurrent_genotype: Genotype&lt;GraphChromosome&lt;Op&lt;f32&gt;&gt;&gt; = recurrent_codec.encode();\nlet recurrent_graph: Graph&lt;Op&lt;f32&gt;&gt; = recurrent_codec.decode(&amp;recurrent_genotype);\n</code></pre>"},{"location":"source/gp/graph/#alters","title":"Alters","text":""},{"location":"source/gp/graph/#graphmutator","title":"GraphMutator","text":"<p>Inputs</p> <ul> <li><code>vertex_rate</code>: f32 - Probabilty of adding a vertex to the graph (0.0 to 1.0)</li> <li><code>edge_rate</code>: f32 - Probabilty of adding an edge to the graph (0.0 to 1.0)</li> <li><code>allow_recurrent</code>: bool - Whether to allow recurrent connections in the graph. The default is <code>true</code>, meaning the graph can have cycles.</li> </ul> <ul> <li>Purpose: Randomly adds vertices and edges to the graph.</li> </ul> <p>This mutator is used to add new nodes and connections to the graph. It can be used to evolve the graph structure over time, allowing for more complex solutions to emerge.</p>  Python Rust <pre><code>import radiate as rd\n\n# Create a mutator that adds vertices and edges with a 10% chance for either\nmutator = rd.GraphMutator(vertex_rate=0.1, edge_rate=0.1, allow_recurrent=False)\n</code></pre> <pre><code>use radiate::*;\n\n// Create a mutator that adds vertices and edges with a 10% chance for either\nlet mutator = GraphMutator::new(0.1, 0.1);\n\nlet mutator = GraphMutator::new(0.1, 0.1).allow_recurrent(false); // Disallow recurrent connections\n</code></pre>"},{"location":"source/gp/graph/#graphcrossover","title":"GraphCrossover","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Crossover rate (0.0 to 1.0)</li> <li><code>cross_parent_node_rate</code>: f32 - Probability of the less fit parent taking a node from the more fit parent (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Swaps node value's (<code>alleles</code>) between two graphs.</li> </ul> <p>This crossover operator is used to combine two parent graphs by swapping the values of their nodes. It can be used to create new graphs that inherit the structure and values of their parents. Given that a more fit parent's node's <code>arity</code> matches the less fit parent's node's <code>arity</code>, the less fit parent will take (inherit) the more fit parent's node's value. This means the child is guaranteed to have the same structure as the less fit parent, but with some of the more fit parent's values (<code>alleles</code>). This process is extremely similar to how the NEAT algorithm works.</p>  Python Rust <pre><code>import radiate as rd\n\ncrossover = rd.GraphCrossover(0.1, 0.5)\n</code></pre> <pre><code>use radiate::*;\n\n// Create a mutator that adds vertices and edges with a 10% chance for either\nlet crossover = GraphCrossover::new(0.1, 0.5);\n</code></pre>"},{"location":"source/gp/node/","title":"Nodes","text":"<p>Nodes are not only the <code>gene</code> of the <code>graph</code> and <code>tree</code>, but the fundamental building blocks of them. Each <code>node</code> represents a connection, computation, or operation, and has explicit rules depending on its role in the structure. </p>"},{"location":"source/gp/node/#roles","title":"Roles","text":"<p>Nodes in the <code>gp</code> system come in different types (roles) depending on whether you're working with trees or graphs:</p> <p>Tree Node Types:</p> <ul> <li>Root: The starting point of a tree (can have any number of children)</li> <li>Vertex: Internal computation nodes (can have any number of children)</li> <li>Leaf: Terminal nodes with no children (arity is <code>Arity::Zero</code>)</li> </ul> <p>Graph Node Types:</p> <ul> <li>Input: Entry points (no incoming connections, one or more outgoing)</li> <li>Output: Exit points (one or more incoming connections, no outgoing)</li> <li>Vertex: Internal computation nodes (both incoming and outgoing connections)</li> <li>Edge: Connection nodes (exactly one incoming and one outgoing connection)</li> </ul> <p>Each node type is defined by the <code>NodeType</code> enum:</p>  Python Rust <p>Node types aren't defined in python - we use strings or input variables instead.</p> <pre><code>pub enum NodeType {\n    Root,    // Tree-specific\n    Vertex,  // Both trees and graphs\n    Leaf,    // Tree-specific\n    Input,   // Graph-specific\n    Output,  // Graph-specific\n    Edge,    // Graph-specific\n}\n</code></pre>"},{"location":"source/gp/node/#store","title":"Store","text":"<p>The <code>NodeStore&lt;T&gt;</code> manages available values for different node types, providing a centralized way to define what values can be used in each position of your genetic program. This makes it super easy to create <code>trees</code> or <code>graphs</code> from a specific template or with a specific structure.</p> <p>Usage Examples:</p>  Python Rust <p>There is no node store for python - it isn't nessesary for the api. Instead, the types of nodes are directly given the their codec or structure.</p> <pre><code>use radiate::*;\n\n// Create a store for tree operations\n// Each vertex node created will have a random value chosen from [1, 2, 3]\n// Each leaf node created will have a random value chosen from [4, 5, 6]\nlet tree_store: NodeStore&lt;i32&gt; = vec![\n    (NodeType::Vertex, vec![1, 2, 3]),\n    (NodeType::Leaf, vec![4, 5, 6]),\n].into();\n\n// -- or use the macro --\n\nlet tree_store: NodeStore&lt;i32&gt; = node_store! {\n    Root =&gt; [1, 2, 3],\n    Vertex =&gt; [1, 2, 3],\n    Leaf =&gt; [4, 5, 6],\n}\n\n// -- with ops --\n// for trees, the input nodes are always the leaf nodes, so we can use the `Op::var` to represent them\nlet op_store: NodeStore&lt;Op&lt;f32&gt;&gt; = node_store! {\n    Root =&gt; [Op::sigmoid()],\n    Vertex =&gt; [Op::add(), Op::mul()],\n    Leaf =&gt; (0..3).map(Op::var).collect::&lt;Vec&lt;_&gt;&gt;(),\n};\n\n// Create a new vertex tree node \nlet tree_node: TreeNode&lt;i32&gt; = tree_store.new_instance(NodeType::Vertex);\n\n// Create a new leaf tree node\nlet leaf_node: TreeNode&lt;Op&lt;f32&gt;&gt; = op_store.new_instance(NodeType::Leaf);\n\n// Create a store for graph operations\n// Each input node created will have a random value chosen from [1, 2]\n// Each edge node created will have a random value chosen from [3, 4]\n// Each vertex node created will have a random value chosen from [5, 6, 7]\n// Each output node created will have a random value chosen from [8, 9, 10]\nlet graph_store: NodeStore&lt;i32&gt; = vec![\n    (NodeType::Input, vec![1, 2]),\n    (NodeType::Edge, vec![3, 4]),\n    (NodeType::Vertex, vec![5, 6, 7]),\n    (NodeType::Output, vec![8, 9, 10]),\n].into();\n\n// -- or use the macro --\n\nlet graph_store: NodeStore&lt;i32&gt; = node_store! {\n    Input =&gt; [1, 2],\n    Edge =&gt; [3, 4],\n    Vertex =&gt; [5, 6, 7],\n    Output =&gt; [8, 9, 10],\n};\n\n// -- with ops --\nlet op_store: NodeStore&lt;Op&lt;f32&gt;&gt; = node_store! {\n    Input =&gt; [Op::var(0), Op::var(1)],\n    Edge =&gt; [Op::add(), Op::mul()],\n    Vertex =&gt; [Op::sub(), Op::div(), Op::max()],\n    Output =&gt; [Op::sigmoid(), Op::tanh(), Op::relu()],\n};\n\n// Create a new vertex graph node at index 0\nlet graph_node: GraphNode&lt;i32&gt; = graph_store.new_instance((0, NodeType::Vertex));\n\n// Createa a new edge graph node at index 1\nlet edge_node: GraphNode&lt;Op&lt;f32&gt;&gt; = op_store.new_instance((1, NodeType::Edge));\n</code></pre> <p>Node Type Mapping:</p> <ul> <li>Tree: <code>Root</code>, <code>Vertex</code>, <code>Leaf</code></li> <li>Graph: <code>Input</code>, <code>Output</code>, <code>Vertex</code>, <code>Edge</code></li> </ul> <p>Store Validation: The node store ensures that:</p> <ul> <li>Each node type has appropriate value</li> <li>Values have compatible arity for their node type</li> <li>Invalid combinations are prevented during evolution</li> </ul>"},{"location":"source/gp/op/","title":"Ops","text":"<p>The <code>ops</code> module provides sets of operations and formats for building and evolve genetic programs including <code>graphs</code> and <code>trees</code>. In the language of radiate, when using an <code>op</code>, it is the <code>Allele</code> of the <code>GraphNode</code> or <code>TreeNode</code>. An <code>op</code> is a function that takes a number of inputs and returns a single output. The <code>op</code> can be a constant value, a variable, or a function that operates on the inputs.   </p> <p>The <code>op</code> comes in five flavors:</p> <ol> <li>Function Operations: Stateless functions that take inputs and return a value.</li> <li>Variable Operations: Read from an input index, returning the value at that index.</li> <li>Constant Operations: Fixed values that do not change - returning the value when called.</li> <li>Mutable Constant Operations: Constants that can change over time, allowing for learnable parameters.</li> <li>Value Operations: Stateful operations that maintain internal state and can take inputs to produce a value.</li> </ol> <p>Each <code>op</code> has an <code>arity</code>, definingt the number of inputs it accepts. For example, the <code>Add</code> operation has an <code>arity</code> of 2 because it takes two inputs and returns their sum. The <code>Const</code> operation has an arity of 0 because it does not take any inputs, it just returns it's value. The <code>Var</code> operation has an arity of 0 because it takes an index as a parameter, and returns the value of the input at that index. </p> <p>Provided <code>Ops</code> include:</p> Basic ops Name Arity Description Initalize Type <code>const</code> 0 x <code>Op::constant()</code> Const <code>named_const</code> 0 x <code>Op::named_constant(name)</code> Const <code>var</code> 0 Variable. input[i] - return the value of the input at index <code>i</code> <code>Op::var(i)</code> Var <code>identity</code> 1 return the input value <code>Op::identity()</code> Fn Basic math operations Name Arity Description Initalize Type <code>Add</code> 2 x + y <code>Op::add()</code> Fn <code>Sub</code> 2 x - y <code>Op::sub()</code> Fn <code>Mul</code> 2 x * y <code>Op::mul()</code> Fn <code>Div</code> 2 x / y <code>Op::div()</code> Fn <code>Sum</code> Any Sum of n values <code>Op::sum()</code> Fn <code>Product</code> Any Product of n values <code>Op::prod()</code> Fn <code>Difference</code> Any Difference of n values <code>Op::diff()</code> Fn <code>Neg</code> 1 -x <code>Op::neg()</code> Fn <code>Abs</code> 1 abs(x) <code>Op::abs()</code> Fn <code>pow</code> 2 x^y <code>Op::pow()</code> Fn <code>Sqrt</code> 1 sqrt(x) <code>Op::sqrt()</code> Fn <code>Abs</code> 1 abs(x) <code>Op::abs()</code> Fn <code>Exp</code> 1 e^x <code>Op::exp()</code> Fn <code>Log</code> 1 log(x) <code>Op::log()</code> Fn <code>Sin</code> 1 sin(x) <code>Op::sin()</code> Fn <code>Cos</code> 1 cos(x) <code>Op::cos()</code> Fn <code>Tan</code> 1 tan(x) <code>Op::tan()</code> Fn <code>Max</code> Any Max of n values <code>Op::max()</code> Fn <code>Min</code> Any Min of n values <code>Op::min()</code> Fn <code>Ceil</code> 1 ceil(x) <code>Op::ceil()</code> Fn <code>Floor</code> 1 floor(x) <code>Op::floor()</code> Fn <code>Weight</code> 1 Weighted sum of n values <code>Op::weight()</code> MutableConst Activation Ops <p>These are the most common activation functions used in Neural Networks.</p> Name Arity Description Initalize Type <code>Sigmoid</code> Any 1 / (1 + e^-x) <code>Op::sigmoid()</code> Fn <code>Tanh</code> Any tanh(x) <code>Op::tanh()</code> Fn <code>ReLU</code> Any max(0, x) <code>Op::relu()</code> Fn <code>LeakyReLU</code> Any x if x &gt; 0 else 0.01x <code>Op::leaky_relu()</code> Fn <code>ELU</code> Any x if x &gt; 0 else a(e^x - 1) <code>Op::elu()</code> Fn <code>Linear</code> Any Linear combination of n values <code>Op::linear()</code> Fn <code>Softplus</code> Any log(1 + e^x) <code>Op::softplus()</code> Fn <code>SELU</code> Any x if x &gt; 0 else a(e^x - 1) <code>Op::selu()</code> Fn <code>Swish</code> Any x / (1 + e^-x) <code>Op::swish()</code> Fn <code>Mish</code> Any x * tanh(ln(1 + e^x)) <code>Op::mish()</code> Fn bool Ops Name Arity Description Initalize Type <code>And</code> 2 x &amp;&amp; y <code>Op::and()</code> Fn <code>Or</code> 2 <code>x || y</code> <code>Op::or()</code> Fn <code>Not</code> 1 !x <code>Op::not()</code> Fn <code>Xor</code> 2 x ^ y <code>Op::xor()</code> Fn <code>Nand</code> 2 !(x &amp;&amp; y) <code>Op::nand()</code> Fn <code>Nor</code> 2 <code>!(x || y)</code> <code>Op::nor()</code> Fn <code>Xnor</code> 2 !(x ^ y) <code>Op::xnor()</code> Fn <code>Equal</code> 2 x == y <code>Op::eq()</code> Fn <code>NotEqual</code> 2 x != y <code>Op::ne()</code> Fn <code>Greater</code> 2 x &gt; y <code>Op::gt()</code> Fn <code>Less</code> 2 x &lt; y <code>Op::lt()</code> Fn <code>GreaterEqual</code> 2 x &gt;= y <code>Op::ge()</code> Fn <code>LessEqual</code> 2 x &lt;= y <code>Op::le()</code> Fn <code>IfElse</code> 3 if x then y else z <code>Op::if_else()</code> Fn  Python Rust <p>Ops in python can't be directly evaluated like in rust. However, they can still be constructed and used in a similar way.</p> <pre><code>import radiate as rd\n\nadd = rd.Op.add()  \nsub = rd.Op.sub()\nmul = rd.Op.mul()\ndiv = rd.Op.div()\n\nconstant = rd.Op.constant(42.0)\nvariable = rd.Op.var(0)\n\nsigmoid = rd.Op.sigmoid()\nrelu = rd.Op.relu()\ntanh = rd.Op.tanh()\n</code></pre> <pre><code>use radiate::*;\n\n// Example usage of an Op\nlet fn_op = Op::add();\nlet result = fn_op.eval(&amp;[1.0, 2.0]); // result is 3.0\n\n// Example usage of a constant Op\nlet const_op = Op::constant(42.0);\nlet result = const_op.eval(&amp;[]); // result is 42.0\n\n// Example usage of a variable Op\nlet var_op = Op::var(0); // Read from input at index 0\nlet inputs = var_op.eval(&amp;[5.0, 10.0]); // result is 5.0 when evaluated with inputs\n</code></pre> <p>Want to create your own <code>Op&lt;T&gt;</code>? Its pretty simple! Let create a custom <code>Square</code> operation that squares it's input.</p> <pre><code>use std::sync::Arc;\nuse radiate::*;\n\nfn my_square_op(inputs: &amp;[f32]) -&gt; f32 {\n    inputs[0] * inputs[0]\n}\n\n// Supply a name, arity (number of inputs - 1 in this case), and function to create the Op\nlet square_op = Op::new(\"Square\", Arity::Exact(1), my_square_op);\n</code></pre> <p>Now you have a new <code>square_op</code> which is completely compatible with the rest of the Radiate GP system and can be plugged in anywhere a regular <code>Op</code> can be used! For more information on creating ops, checkout the API docs to see how the rest are created - its not too crazy. </p>"},{"location":"source/gp/op/#alters","title":"Alters","text":""},{"location":"source/gp/op/#operationmutator","title":"OperationMutator","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Mutation rate (0.0 to 1.0)</li> <li><code>replace_rate</code>: f32 - Rate at which to replace an old <code>op</code> with a completely new one (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Randomly mutate an operation within a <code>TreeNode</code> or <code>GraphNode</code>.</li> </ul> <p>This mutator randomly changes or alters the <code>op</code> of a node within a <code>TreeChromosome</code> or <code>GraphChromosome</code>. It can replace the <code>op</code> with a new one from the store or modify its parameters.</p>  Python Rust <pre><code>import radiate as rd\n\n# Create a mutator that has a 10% chance to mutate an op and a 50% chance to replace it with a new one\nmutator = rd.OperationMutator(0.1, 0.5)\n</code></pre> <pre><code>use radiate::*;\n\n// Create a mutator that has a 10% chance to mutate an op and a 50% chance to replace it with a new one\nlet mutator = OperationMutator::new(0.1, 0.5);\n</code></pre>"},{"location":"source/gp/pgm/","title":"PGM","text":"<p> Under Construction </p> <p>As of <code>01/15/2026</code>: These docs are a work in progress. Please check back later for updates.</p> <p>Probabilistic Graphical Models (PGMs) are currently being developed and integrated into radiate. This documentation will be updated to reflect the latest features and capabilities as they become available.</p> <p>As of the next release of radiate (1.2.21) the current (1.2.20) state of PGMs will be deprecated and removed. ie: the current PGM implementation will be replaced with a more robust and feature-complete version in the upcoming release.</p> <p>Probabilistic Graphical Models (PGMs) in radiate allow for the representation and manipulation of probabilistic relationships between variables. They are a way to represent, reason about, and compute with uncertainty by combining probability theory and graph theory. They provide a structured framework for modeling complex systems where variables are interdependent and uncertainty is inherent.</p> <p>Suppose you have many random variables that is exponentially large and infeasible to store or reason about directly. For example, representing a full joint distribution such as</p> \\[ P(X_1, X_2, \\dots, X_n) \\] <p>is often impractical because the number of possible configurations grows exponentially with the number of variables.</p> <p>PGMs exploit conditional independence:</p> <ul> <li>If variable A only depends on B and C, you don\u2019t need to model how it depends on everything else.</li> </ul> <p>This allows us to factor the joint distribution into smaller, more manageable pieces. For example, if we have a set of variables {X1, X2, X3} where X1 depends on X2 and X3, we can express the joint distribution as:</p> \\[ P(X_1, X_2, X_3) = P(X_1 | X_2, X_3) * P(X_2) * P(X_3) \\] <p>So, in english, you could say \"if its raining (X2) and its 8am (X3), then the probability of me being late for work (X1) is high\".</p> <p>This factorization reduces the complexity of the model and makes it easier to work with.</p>"},{"location":"source/gp/regression/","title":"Regression","text":"<p>In machine learning its common to have a regression task. This is where you have a set of inputs and outputs, and you want to find a function that maps the inputs to the outputs. In Radiate, we can use genetic programming to evolve a <code>tree</code> or <code>graph</code> to do just that. The regression <code>problem</code> is a special type of <code>problem</code> that simplifies this process. It provides functionality to normalize/standarize/OHE the inputs and outputs, as well as calculate the fitness of a <code>genotype</code> based on how well it maps the inputs to the outputs.</p> <p>The regression problem (fitness function) takes a set of inputs and outputs, and optionally a loss function. The default loss function is mean squared error (MSE), but other options include MAE (mean average error), CrossEntropy loss, and Diff (Difference - a simple difference between output and target).</p> <p>Lets take a quick look at how we would put together a regression problem using a <code>tree</code> and a <code>graph</code>.</p>  Python Rust <pre><code>import radiate as rd\n\nrd.random.seed(518)\n\ndef compute(x: float) -&gt; float:\n    return 4.0 * x**3 - 3.0 * x**2 + x\n\n\ninputs = []\nanswers = []\n\n# Create a simple dataset of 20 points where the input is between -1 and 1\n# and the output is the result of the compute function above \ninput = -1.0\nfor _ in range(-10, 10):\n    input += 0.1\n    inputs.append([input])\n    answers.append([compute(input)])\n\n# Create a simple GraphCodec which takes one input and produces one output\n# The graph will have vertex nodes that can add, subtract, or multiply\n# The edges will have a weight operation and the output will be linear\ncodec = rd.GraphCodec.directed(\n    shape=(1, 1),\n    vertex=[rd.Op.sub(), rd.Op.mul(), rd.Op.linear()],\n    edge=rd.Op.weight(),\n    output=rd.Op.linear(),\n)\n\n# All we have to do to create a regression problem is provide the features &amp; targets for our \n# dataset. Optionally, we can provide a loss function as well - the default is mean squared error (MSE).\n# The last argument is whether to use batch evaluation or not - the default is False. This has minimal impact on performance.\nfitness_func = rd.Regression(inputs, answers, loss=\"mse\", batch=False)   \n\nengine = rd.GeneticEngine(\n    codec=codec,\n    fitness_func=fitness_func,\n    objective=\"min\",   # Minimize the loss\n    alters=[\n        rd.GraphCrossover(0.5, 0.5),\n        rd.OperationMutator(0.07, 0.05),\n        rd.GraphMutator(0.1, 0.1, allow_recurrent=False), # True if evolving recurrent graphs is allowed\n    ],\n)\n\n# Run the genetic engine with a score (error) limit of 0.001 or a maximum of 1000 generations\nresult = engine.run([rd.ScoreLimit(0.001), rd.GenerationsLimit(1000)], log=True)\n</code></pre> <pre><code>use radiate::*;\n\nconst MIN_SCORE: f32 = 0.001;\n\nfn main() {\n    // Set the random seed for reproducibility\n    random_provider::set_seed(1000);\n\n    // Define our node store for the graph - the operations that can be used by each \n    // node type in the graph during evolution\n    let store = vec![\n        (NodeType::Input, vec![Op::var(0)]),\n        (NodeType::Edge, vec![Op::weight()]),\n        (NodeType::Vertex, vec![Op::sub(), Op::mul(), Op::linear()]),\n        (NodeType::Output, vec![Op::linear()]),\n    ];\n\n    let engine = GeneticEngine::builder()\n        .codec(GraphCodec::directed(1, 1, store))\n        .fitness_fn(Regression::new(dataset(), Loss::MSE))\n        .minimizing()\n        .alter(alters!(\n            GraphCrossover::new(0.5, 0.5),\n            OperationMutator::new(0.07, 0.05),\n            GraphMutator::new(0.1, 0.1).allow_recurrent(false)\n        ))\n        .build();\n\n    engine\n        .iter()\n        .logging()\n        .until_score(MIN_SCORE)\n        .last()\n        .inspect(display);\n}\n\n// A simple function to take the output of the engine and display the accuracy \n// of the result on the dataset\nfn display(result: &amp;Generation&lt;GraphChromosome&lt;Op&lt;f32&gt;&gt;, Graph&lt;Op&lt;f32&gt;&gt;&gt;) {\n    Accuracy::default()\n        .named(\"Regression Graph\")\n        .on(&amp;dataset().into())\n        .loss(Loss::MSE)\n        .eval(result.value())\n        .inspect(|acc| {\n            println!(\"{result:?}\\n{acc:?}\\n{}\", result.metrics().dashboard());\n        });\n}\n\nfn dataset() -&gt; impl Into&lt;DataSet&gt; {\n    let mut inputs = Vec::new();\n    let mut answers = Vec::new();\n\n    let mut input = -1.0;\n    for _ in -10..10 {\n        input += 0.1;\n        inputs.push(vec![input]);\n        answers.push(vec![compute(input)]);\n    }\n\n    (inputs, answers)\n}\n\nfn compute(x: f32) -&gt; f32 {\n    4.0 * x.powf(3.0) - 3.0 * x.powf(2.0) + x\n}\n</code></pre> <p>More robust examples can be found in the next section or in the tree and graph examples in the git repository.</p>"},{"location":"source/gp/trees/","title":"Trees","text":"<p>A <code>tree</code> represents a hierarchical structure where each node has exactly one parent (except the root) and zero or more children. When combined with the ops, it allows for the evolution of mathematical expressions, decision trees, and symbolic regression.</p>"},{"location":"source/gp/trees/#building-a-tree","title":"Building a Tree","text":"Python Rust <p>Trees in python aren't quite as expressive as in rust, but they can still be constructed and used in a similar way.</p> <pre><code>import radiate as rd\n\ntree = rd.Tree(\n    min_height=3,       # Default\n    max_size=30,        # Default\n    root=rd.Op.add(),   # The root operation - isn't necessary to specify\n    vertex=[rd.Op.add(), rd.Op.sub(), rd.Op.mul(), rd.Op.div()],\n    leaf=[rd.Op.var(0), rd.Op.var(1)],\n)\n\nresult = tree.eval([1, 2]) \n</code></pre> <pre><code>use radiate::*;\n\n// create a simple tree:\n//              42\n//           /  |   \\\n//          1   2    3\n//             / \\    \n//            3   4    \nlet tree: Tree&lt;i32&gt; = Tree::new(TreeNode::new(42)\n    .attach(TreeNode::new(1))\n    .attach(TreeNode::new(2)\n        .attach(TreeNode::new(3))\n        .attach(TreeNode::new(4))\n    .attach(TreeNode::new(3))));\n\n// The tree can be evaluated with a function that takes a vector of inputs\n// This creates a `Tree` that looks like:\n//      +\n//    /   \\\n//   *     +\n//  / \\   / \\\n// 2  3  2   x\n//\n// Where `x` is the first variable in the input.\n// This can also be thought of (and is functionally equivalent) as:\n//\n// f(x) = (2 * 3) + (2 + x)\n//\nlet root = TreeNode::new(Op::add())\n    .attach(\n        TreeNode::new(Op::mul())\n            .attach(TreeNode::new(Op::constant(2.0)))\n            .attach(TreeNode::new(Op::constant(3.0))),\n    )\n    .attach(\n        TreeNode::new(Op::add())\n            .attach(TreeNode::new(Op::constant(2.0)))\n            .attach(TreeNode::new(Op::var(0))),\n    );\n\n// And the result of evaluating this tree with an input of `1` would be:\nlet result = root.eval(&amp;vec![1_f32]);\nassert_eq!(result, 9.0);\n</code></pre> <p>Key Properties:</p> <ul> <li>Rooted: Always has a single root node</li> <li>Acyclic: No node is its own ancestor</li> <li>Hierarchical: Parent-child relationships</li> </ul>"},{"location":"source/gp/trees/#node","title":"Node","text":"<p>Each node in a tree contains a value and optional children &amp; arity. The <code>TreeNode</code> also implements the <code>gene</code> trait, making the node itself a <code>gene</code> and it's value the <code>allele</code>. </p> <p>Node Types:</p> <ul> <li>Root: Starting point of the tree (can have any number of children)</li> <li>Vertex: Internal computation nodes (can have any number of children)</li> <li>Leaf: Terminal nodes with no children (arity is <code>Arity::Zero</code>)</li> </ul>"},{"location":"source/gp/trees/#codec","title":"Codec","text":"<p>The <code>TreeCodec</code> is simply a <code>codec</code> that encodes a <code>TreeChromosome</code> and decodes it back into a <code>Tree</code>. The <code>TreeCodec</code> can be configured to create a single <code>tree</code> or a multi-root <code>tree</code> structure. </p> <p>Codec Types:</p> <ul> <li>Single Root: Creates one tree per <code>genotype</code></li> <li>Multi-Root: Creates multiple trees per <code>genotype</code></li> </ul>  Python Rust <pre><code>import radiate as rd\n\n# Create a tree codec with a starting (minimum) depth of 3\ncodec = rd.TreeCodec(\n    shape=(2, 1),\n    min_depth=3,\n    max_size=30,\n    root=rd.Op.add(),\n    vertex=[rd.Op.add(), rd.Op.sub(), rd.Op.mul()],\n    leaf=[rd.Op.var(0), rd.Op.var(1)],\n)\n\ngenotype = codec.encode()  \ntree = codec.decode(genotype)\n</code></pre> <pre><code>use radiate::*;\n\nlet store = vec![\n    (NodeType::Root, vec![Op::add(), Op::sub()]),\n    (NodeType::Vertex, vec![Op::add(), Op::sub(), Op::mul()]),\n    (NodeType::Leaf, vec![Op::constant(1.0), Op::constant(2.0)]),\n];\n\n// Create a single rooted tree codec with a starting (minimum) depth of 3\nlet codec = TreeCodec::single(3, store);\nlet genotype: Genotype&lt;TreeChromosome&lt;Op&lt;f32&gt;&gt;&gt; = single_root_codec.encode();\nlet tree: Tree&lt;Op&lt;f32&gt;&gt; = codec.decode(&amp;genotype);\n\n// Create a multi-rooted tree codec with a starting (minimum) depth of 3 and 2 trees\nlet codec = TreeCodec::multi_root(3, 2, store);\nlet genotype: Genotype&lt;TreeChromosome&lt;Op&lt;f32&gt;&gt;&gt; = codec.encode();\n// multi-rooted codec decodes to a Vec of Trees\n// one for each root in the genotype\nlet trees: Vec&lt;Tree&lt;Op&lt;f32&gt;&gt;&gt; = codec.decode(&amp;genotype); \n</code></pre>"},{"location":"source/gp/trees/#alters","title":"Alters","text":""},{"location":"source/gp/trees/#hoistmutator","title":"HoistMutator","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Mutation rate (0.0 to 1.0)</li> </ul> <ul> <li>Purpose:  Randomly hoists subtrees from one part of the tree to another.</li> </ul> <p>The <code>HoistMutator</code> is a mutation operator that randomly selects a subtree from the tree and moves it to a different location in the tree. This can create new structures and relationships between nodes, allowing for more complex solutions to emerge.</p>  Python Rust <pre><code>import radiate as rd\n\nmutator = rd.HoistMutator(rate=0.1)\n</code></pre> <pre><code>use radiate::*;\n\nlet mutator = HoistMutator::new(0.1);\n</code></pre>"},{"location":"source/gp/trees/#treecrossover","title":"TreeCrossover","text":"<p>Inputs</p> <ul> <li><code>rate</code>: f32 - Mutation rate (0.0 to 1.0)</li> </ul> <ul> <li>Purpose: Swaps two subtrees between two trees.</li> </ul> <p>The <code>TreeCrossover</code> is a crossover operator that randomly selects a subtree from one parent tree and swaps it with a subtree from another parent tree.</p>  Python Rust <pre><code>import radiate as rd\n\nmutator = rd.TreeCrossover(rate=0.1)\n</code></pre> <pre><code>use radiate::*;\n\nlet mutator = TreeCrossover::new(0.1);\n</code></pre>"},{"location":"source/misc/","title":"Miscellaneous","text":"<p>This section contains various miscellaneous information about the Radiate library that doesn't fit into other sections.</p>"},{"location":"source/misc/checkpoint/","title":"Checkpointing","text":"<p>Radiate provides built-in support for checkpointing, allowing you to save the state of your genetic algorithm at regular intervals. This is particularly useful for long-running experiments, as it enables you to resume from the last checkpoint in case of interruptions.</p>  Python Rust <pre><code>import radiate as rd\n\ntarget = \"Hello, Radiate!\"\n\ndef fitness_func(x: list[str]) -&gt; int:\n    return sum(1 for i in range(len(target)) if x[i] == target[i])\n\nengine = rd.GeneticEngine(\n    codec=rd.CharCodec.vector(len(target)),\n    fitness_func=fitness_func,\n    offspring_selector=rd.BoltzmannSelector(4),\n)\n\nresult = engine.run(rd.ScoreLimit(len(target)), checkpoint=(10, \"checkpoint.json\"))\n\n# load from checkpoint from generation 10\nengine = rd.GeneticEngine(\n    codec=rd.CharCodec.vector(len(target)),\n    fitness_func=fitness_func,\n    offspring_selector=rd.BoltzmannSelector(4),\n    checkpoint_path=\"checkpoint_10.json\",\n)\n\nresult = engine.run(rd.ScoreLimit(len(target)))\n</code></pre> <pre><code>use radiate::*;\n\nfn main() {\n    let target = \"Hello, Radiate!\";\n    let target_len = target.len();\n\n    fn fitness_fn(geno: Vec&lt;char&gt;) -&gt; Score {\n        geno.into_iter().zip(target.chars()).fold(\n            0,\n            |acc, (allele, targ)| {\n                if allele == targ { acc + 1 } else { acc }\n            },\n        ).into()\n    }\n\n    let engine = GeneticEngine::builder()\n        .codec(CharCodec::vector(target.len()))\n        .offspring_selector(BoltzmannSelector::new(4_f32))\n        .fitness_fn(fitness_fn)\n        .build();\n\n    let result = engine.iter()\n        .checkpoint(10, \"checkpoint.json\")\n        .until_score(target_len)\n        .last()\n        .expect(\"No result from engine run\");\n\n    // load from checkpoint from generation 10\n    let resumed_engine = GeneticEngine::builder()\n        .codec(CharCodec::vector(target.len()))\n        .offspring_selector(BoltzmannSelector::new(4_f32))\n        .fitness_fn(fitness_fn)\n        .load_checkpoint(\"checkpoint_10.json\")\n        .build();\n\n    let resumed_result = resumed_engine.iter()\n        .until_score(target_len)\n        .last()\n        .expect(\"No result from resumed engine run\");\n}\n</code></pre>"},{"location":"source/misc/problem/","title":"Problem API","text":"<p>For certain optimization problems, it is useful to have a more structured way to define a <code>problem</code>. For instance, it may be useful to hold stateful information within a fitness function, store data in a more unified way, or evaluate a <code>Genotype&lt;C&gt;</code> directly without decoding. The <code>problem</code> interface provides a way to do just that. Under the hood of the <code>GeneticEngine</code>, the builder constructs a <code>problem</code> object that holds the <code>codec</code> and fitness function. Because of this, when using the <code>problem</code> API, we don't need a <code>codec</code> or a fitness function - the <code>problem</code> will take care of that for us. </p> <p>See the image evolution example for a more detailed example of using the <code>problem</code> API.</p>  Python Rust <p>The <code>Problem</code> interface is not available in python because it isn't needed.</p> <pre><code>use radiate::*;\n\n// Define a problem struct that holds stateful information\nstruct MyFloatProblem {\n    num_genes: usize,\n    value_range: Range&lt;f32&gt;,\n}\n\nimpl Problem&lt;FloatChromosome, Vec&lt;f32&gt;&gt; for MyFloatProblem {\n    fn encode(&amp;self) -&gt; Genotype&lt;FloatChromosome&gt; {\n        Genotype::from(FloatChromosome::from((self.num_genes, self.value_range.clone())))\n    }\n\n    fn decode(&amp;self, genotype: &amp;Genotype&lt;FloatChromosome&gt;) -&gt; Vec&lt;f32&gt; {\n        genotype.genes().iter().map(|gene| gene.value()).collect()\n    }\n\n    fn eval(&amp;self, genotype: &amp;Genotype&lt;FloatChromosome&gt;) -&gt; Score {\n        // Evaluate the genotype directly without decoding\n        my_fitness_fn(&amp;genotype)\n    }\n}\n\n// The `Problem&lt;C, T&gt;` trait requires `Send` and `Sync` implementations\nunsafe impl Send for MyFloatProblem {}\nunsafe impl Sync for MyFloatProblem {}\n\n// Create an engine with the problem\nlet mut engine = GeneticEngine::builder()\n    .problem(MyProblem { num_genes: 10, value_range: 0.0..1.0 })\n    .build();\n\n// Run the engine\nlet result = engine.run(|epoch| epoch.index() &gt;= 100);\n</code></pre>"},{"location":"source/misc/random/","title":"Random","text":"<p>Random number generation is a crucial aspect of evolutionary algorithms. Radiate provides a random interface that governs all random number generation within the library through the <code>random_provider</code>. This allows for consistent and reproducible results across different runs of the algorithm.</p> <p>Through the <code>random_provider</code>, you can access various random number generation methods, such as generating random floats, integers, bools, selecting random elements from a list, shuffling elements in a list, among others. This ensures that all stochastic processes within the library are controlled and can be easily managed.</p> <p>Here's an example of how to use the <code>random_provider</code>:</p>  Python Rust <pre><code>import radiate as rd\n\n# set a seed for reproducibility\nrd.random.seed(42)  \n\n# random float\nrand_float = rd.random.float(min=0.0, max=1.0)\n\n# random integer\nrand_int = rd.random.int(min=0, max=10)\n\n# random bool with 50% chance of being true\nrand_bool = rd.random.bool(prob=0.5)\n\n# randomly sample 2 elements from a list\nrand_choice = rd.random.sample(data=[1, 2, 3, 4, 5], count=2)\n\n# choose a random element from a list\nrand_element = rd.random.choose(data=[1, 2, 3, 4, 5])\n</code></pre> <pre><code>use radiate::*;\n\n// set a seed for reproducibility\nrandom_provider::set_seed(42);\n\n// generate random values in ranges\nlet rand_float = random_provider::range(0.0..1.0);\nlet rand_int = random_provider::range(0..10);\n\n// random bool with 50% chance of being true\nlet rand_bool = random_provider::bool(0.5);\n\n// choose a random element from a slice and shuffle a vector\nlet rand_choice = random_provider::choose(&amp;[1, 2, 3, 4, 5]);\n\n// shuffle a vector in place\nlet mut vec = vec![1, 2, 3, 4, 5];\nrandom_provider::shuffle(&amp;mut vec);\n\n// random gaussian float with mean 0 and stddev 1\nlet rand_gauss = random_provider::gaussian(0.0, 1.0);\n\n// randomly sample n elements from a slice - range of indices, probability of each index being included\nlet conditional_indices = random_provider::cond_indices(0..10, 0.2);\n\n// get a scoped random instance which maintains state from the calling random provider\n// be aware that this is not thread-safe and should only be used in single-threaded contexts\nrandom_provider::with_rng(|rng| {\n    let scoped_rand_float = rng.range(0.0..1.0);\n    let gaussian_float = rng.gaussian(0.0, 1.0);\n});\n</code></pre>"},{"location":"source/misc/ui/","title":"UI","text":"<p>User Interface</p> <p>Requires the <code>ui</code> feature flag</p> <p>Python includes this feature by default. However, in Rust, you need to enable the <code>ui</code> feature flag when adding Radiate as a dependency.</p> <pre><code>[dependencies]\nradiate = { version = \"x\", features = [\"ui\"] }\n</code></pre> <p>Radiate includes a simple terminal command-line user interface (TUI) built with ratatui for monitoring and controlling evolutionary runs. It provides real-time feedback on the progress of the evolution, including a plethora of statistics and visualizations. </p>"},{"location":"source/misc/ui/#statistics-timings","title":"Statistics &amp; Timings","text":"<p>Below we can see the base TUI layout during an evolutionary run:</p> <p>The TUI is composed of several sections:</p> <ul> <li> <p>Top Left: Displays base level information about the current engine, including the current generation, best fitness, and elapsed time followed by some useful statistics about the population.</p> </li> <li> <p>Top Right: A line graph showing the best fitness over generations.</p> </li> <li> <p>Bottom: Statistics collected throughout the engine's run. This will include information about the genetic operators used, such as selection, crossover, and mutation statistics. As you scroll the statistics panel, a line graph will appear on the bottom showing the history of the selected statistic.</p> </li> </ul> <p>Its also possible to view the timings of various components of the genetic algorithm. This can be enabled by pressing the <code>h/l</code> (swap left/right between panels) key during an evolutionary run. Again, as you scroll through the timings panel, a pie chart will light up with the corresponding timing information. </p>"},{"location":"source/misc/ui/#filtering","title":"Filtering","text":"<p>Because the engine collects so many statistics, its also possible to filter the statistics by their <code>tag</code>s. You can do this by pressing the <code>f</code> key during an evolutionary run, which will bring up a prompt to enter a tag to filter by. For example, if I just want to see statistics related to <code>alters</code>, I can press <code>f</code> and enter and toggle the appropriate tags:</p>"},{"location":"source/misc/ui/#multi-objective","title":"Multi-objective","text":"<p>The TUI also supports multi-objective evolutionary runs. In this case, the top-right panel will show a scatter plot of the Pareto front, with each axis representing one of the objectives being optimized.</p>"},{"location":"source/misc/ui/#using-the-tui","title":"Using the TUI","text":"<p>The TUI is completely opt-in and can be configured as shown below</p>  Python Rust <pre><code>import radiate as rd\n\nengine = rd.GeneticEngine(\n    # ... configure your engine as normal ...\n)\n\n# Enable the UI by passing ui=True to run() Note that this will disable logging if log=True\nresult = engine.run(\n    [rd.ScoreLimit(0.001), rd.GenerationsLimit(1000)],\n    ui=True,\n)\nprint(result)\n</code></pre> <pre><code>use radiate::*;\n\nconst MIN_SCORE: i32 = 100;\n\nlet engine = GeneticEngine::builder()\n    // ... configure your engine as normal ...\n    .build();\n\n// Wrap the engine with the UI\nlet final_generation = radiate::ui(engine)\n    .iter()\n    .until_score(MIN_SCORE)\n    .last()\n    .unwrap();\n</code></pre>"},{"location":"source/misc/ui/#navigation","title":"Navigation","text":"<p>The TUI can be navigated using the following keybindings (or see the help menu by pressing <code>?</code> or <code>H</code>):</p> Key Action <code>q</code> Quit the UI <code>?</code> / <code>H</code> Toggle this help <code>p</code> Pause / Resume engine <code>n</code> Step one epoch (stays paused) <code>j</code> / Down Move selection down <code>k</code> / Up Move selection up <code>h</code> / Left Previous metrics tab <code>l</code> / Right Next metrics tab <code>[</code> / <code>]</code> Prev / next objective-pair page <code>+</code> / <code>-</code> Expand / shrink objective pairs <code>c</code> Toggle value mini chart <code>m</code> Toggle mean mini chart <code>f</code> Toggle tag filters panel <code>Enter</code> Toggle tag selection <code>Esc</code> Clear tag filters <code>0-9</code> Select filter by index"},{"location":"source/selectors/","title":"Selectors","text":"<p>Selectors in a genetic algorithm are responsible for selecting individuals from the population to create the next generation. Radiate does this in two ways, selecting for survivors and selecting for offspring. The survivors get passed directly down into the new generation, while the offspring are used to create new individuals through <code>alters</code> like <code>mutation</code> and <code>crossover</code>. The <code>population</code> is treated as a  distribution of individuals, and the <code>selector</code> is responsible for sampling from this distribution to create the next generation.</p> <p>The selection process is a critical part of the genetic algorithm, as it determines which individuals will be passed on to the next generation and which will be discarded. A majority of the time the selection process is based on the fitness of the individuals in the population, with fitter individuals being more likely to be selected. The choice of selection strategy can have a significant impact on the performance of the genetic algorithm, so it is important to choose a selection strategy that is well-suited to the problem being solved.</p> <p>Radiate provides a number of built-in selectors that can be used to customize the selection process.</p>"},{"location":"source/selectors/#overview","title":"Overview","text":"Selector Best For Selection Pressure Diversity Tournament Most problems Adjustable (via k) High Roulette Most problems High Medium Boltzmann Most problems Adjustable (via temp) Medium-High Elite Preserving best solutions Very High Low NSGA-II Multi-objective problems Balanced High Stochastic Reducing bias Medium High Rank Erratic fitness Medium High Linear Rank Linear scaling Adjustable (via pressure) Medium-High Random Testing Low High Steady State Maintaining population stability Low Medium Tournament NSGA-II Multi-objective problems Balanced High"},{"location":"source/selectors/#elite","title":"Elite","text":"<p>The <code>EliteSelector</code> is a selection strategy that selects the top <code>n</code> individuals from the population based on their fitness values. This can be useful for preserving the best individuals in the population and preventing them from being lost during the selection process. </p> <p>Warning</p> <p>This is a deterministic selection strategy that always selects the same individuals from the population. This can lead to premature convergence and lack of diversity in the population, so it is important to use it judiciously.</p>  Python Rust <pre><code>import radiate as rd\n\nselector = rd.EliteSelector()\n</code></pre> <pre><code>use radiate::*;\n\nlet selector = EliteSelector::new();\n</code></pre>"},{"location":"source/selectors/#tournament","title":"Tournament","text":"<p>Inputs</p> <ul> <li><code>num</code>: usize - The number of individuals to compete in each tournament.</li> </ul> <p>The <code>TournamentSelector</code> is a selection strategy that selects individuals from the <code>population</code> by holding a series of tournaments. In each tournament, a random subset of size <code>num</code> of individuals is selected, and the fittest individual from that subset is chosen. This can help to maintain diversity in the <code>population</code> and prevent premature convergence by allowing weaker individuals to be selected occasionally.</p> <p>Create a new <code>TournamentSelector</code> with a tournament size of 3</p>  Python Rust <pre><code>import radiate as rd\n\nselector = rd.TournamentSelector(k=3)\n</code></pre> <pre><code>use radiate::*;\n\nlet selector = TournamentSelector::new(3);\n</code></pre>"},{"location":"source/selectors/#roulette","title":"Roulette","text":"<p>The <code>RouletteSelector</code> is a selection strategy that selects individuals from the <code>population</code> based on their fitness values. The probability of an individual being selected is proportional to its fitness value, so fitter individuals are more likely to be chosen. The probability of an individual being selected is:</p> \\[ p_{i}={\\frac {f_{i}}{\\Sigma _{j=1}^{N}f_{j}}} \\] <p>Where</p> <ul> <li>\\(p_{i}\\) is the probability of individual \\(i\\) being selected</li> <li>\\(f_{i}\\) is the fitness value of individual \\(i\\)</li> <li>\\(N\\) is the total number of individuals in the <code>population</code>.</li> </ul> <p>This is an extremely popular selection strategy due to its simplicity and effectiveness. Due to the random nature of the selection process, it can help to maintain diversity in the <code>population</code> and prevent premature convergence.</p>  Python Rust <pre><code>import radiate as rd\n\nselector = rd.RouletteSelector()\n</code></pre> <pre><code>use radiate::*;\n\nlet selector = RouletteSelector::new();\n</code></pre>"},{"location":"source/selectors/#boltzmann","title":"Boltzmann","text":"<p>Inputs</p> <ul> <li><code>temperature</code>: f32 - The temperature of the selection process.</li> </ul> <p>The <code>BoltzmannSelector</code> is a probabilistic selection strategy inspired by the Boltzmann distribution from statistical mechanics, where selection probabilities are scaled based on temperature. Temperature influences the balance between exploration and exploitation during the algorithm\u2019s run.</p> <p>As the temperature decreases, the selection process becomes more deterministic, with fitter individuals being more likely to be selected. Conversely, as the temperature increases, the selection process becomes more random, with all individuals having an equal chance of being selected.</p>  Python Rust <p>If the <code>temperature</code> is not specified, it defaults to 1.0.</p> <pre><code>import radiate as rd\n\nselector = rd.BoltzmannSelector(temp=4.0)\n</code></pre> <pre><code>use radiate::*;\n\nlet selector = BoltzmannSelector::new(4_f32);\n</code></pre>"},{"location":"source/selectors/#nsga-ii","title":"NSGA-II","text":"<p>The <code>NSGA2Selector</code> is a selection strategy used in multi-objective optimization problems. It is based on the Non-Dominated Sorting Genetic Algorithm II (NSGA-II) and selects individuals based on their Pareto dominance rank and crowding distance. The NSGA-II algorithm is designed to maintain a diverse set of solutions that represent the trade-offs between multiple conflicting objectives.</p> <ul> <li>Individuals are first sorted into Pareto fronts based on their dominance relationships.</li> <li>Individuals in the same front are then ranked based on their crowding distance, which measures the density of solutions around them.</li> <li>Individuals with lower ranks and higher crowding distances are more likely to be selected.</li> </ul>  Python Rust <pre><code>import radiate as rd\n\nselector = rd.NSGA2Selector()\n</code></pre> <pre><code>use radiate::*;\n\nlet selector = NSGA2Selector::new();\n</code></pre>"},{"location":"source/selectors/#tournament-nsga-ii","title":"Tournament NSGA-II","text":"<p>The <code>TournamentNSGA2Selector</code> is a selection strategy that combines the principles of tournament selection with the NSGA-II algorithm. It selects individuals based on their Pareto dominance rank and crowding distance, but uses a tournament-style approach to select individuals from each Pareto front.</p> <ul> <li>Individuals are first sorted into Pareto fronts based on their dominance relationships.</li> <li>A tournament is held within each Pareto front, where a random subset of individuals is selected.</li> <li>The winner of the tournament is selected based on their crowding distance, which measures the density of solutions around them.</li> </ul>  Python Rust <pre><code>import radiate as rd\n\nselector = rd.TournamentNSGA2Selector()\n</code></pre> <pre><code>use radiate::*;\n\nlet selector = TournamentNSGA2Selector::new();\n</code></pre>"},{"location":"source/selectors/#stochastic-universal-sampling","title":"Stochastic Universal Sampling","text":"<p>Stochastic Universal Sampling (SUS) is a probabilistic selection technique used to ensure that selection is proportional to fitness, while maintaining diversity. Some consider it an improvement over roulette wheel selection, designed to reduce bias and randomness in the selection process by ensuring all individuals have a chance to be chosen, proportional to their fitness values.</p> <ol> <li>Fitness Proportional Selection:<ul> <li>Each individual in the population is assigned a segment of a virtual \u201croulette wheel,\u201d where the size of the segment is proportional to the individual\u2019s fitness.</li> <li>Individuals with higher fitness occupy larger segments.</li> </ul> </li> <li>Single Spin with Multiple Pointers:<ul> <li>Unlike traditional roulette wheel selection, which spins the wheel multiple times (once per selection), SUS uses a single spin and places multiple evenly spaced pointers on the wheel.</li> <li>The distance between the pointers is: <code>d = total_fitness / n</code>, where <code>n</code> is the number of individuals to select.</li> </ul> </li> <li>Selection:<ul> <li>The wheel is spun once, and the pointers are placed on the wheel at random positions.</li> <li>Individuals whose segments are intersected by the pointers are selected.</li> </ul> </li> </ol>  Python Rust <pre><code>import radiate as rd\n\nselector = rd.StochasticSamplingSelector()\n</code></pre> <pre><code>use radiate::*;\n\nlet selector = StochasticUniversalSamplingSelector::new();\n</code></pre>"},{"location":"source/selectors/#rank","title":"Rank","text":"<p>The <code>RankSelector</code> is a selection strategy that selects individuals from the <code>population</code> based on their rank, or index, in the <code>population</code>. The fitness values of the individuals are first ranked, and then the selection probabilities are assigned based on these ranks. This helps to maintain diversity in the population and prevent premature convergence by ensuring that all individuals have a chance to be selected, regardless of their fitness values.</p>  Python Rust <pre><code>import radiate as rd\n\nselector = rd.RandkSelector()\n</code></pre> <pre><code>use radiate::*;\n\nlet selector = RankSelector::new();\n</code></pre>"},{"location":"source/selectors/#linear-rank","title":"Linear Rank","text":"<p>Inputs</p> <ul> <li><code>pressure</code>: f32 - The scaling factor for the selection probabilities.</li> </ul> <p>The <code>LinearRankSelector</code> is a selection strategy that selects individuals from the <code>population</code> based on their rank, or index, in the <code>population</code>, but with a linear scaling of the selection probabilities. The fitness values of the individuals are first ranked, and then the scaling factor is applied to the ranks. This helps to maintain diversity in the <code>population</code> and prevent premature convergence by ensuring that all individuals have a chance to be selected, but with a bias towards fitter individuals. The linear scaling function is defined as follows:</p> \\[ p_{i}={\\Sigma _{i=1}^{N}r_{i}} * pressure \\] <p>Where</p> <ul> <li>\\(p_{i}\\) is the probability of individual \\(i\\) being selected</li> <li>\\(r_{i}\\) is the rank of individual \\(i\\)</li> <li>\\(N\\) is the total number of individuals in the <code>population</code> </li> <li><code>pressure</code> is a scaling factor that can be adjusted to control</li> </ul> <p>A higher <code>pressure</code> will result in a stronger bias towards fitter individuals, while a lower value will result in a more uniform selection.</p>  Python Rust <p>If <code>pressure</code> is not specified, it defaults to <code>0.5</code>.</p> <pre><code>import radiate as rd\n\nselector = rd.LinearRankSelector(pressure=0.1)\n</code></pre> <pre><code>use radiate::*;\n\nlet selector = LinearRankSelector::new(0.1);\n</code></pre>"},{"location":"source/selectors/#random","title":"Random","text":"<p>The <code>RandomSelector</code> is a selection strategy that selects individuals from the <code>population</code> at random. It allows all individuals to have an equal chance of being selected, regardless of their fitness values. There is no bias towards fitter individuals, making it a simple and straightforward selection strategy. However, it may not be as effective in maintaining diversity in the <code>population</code> and preventing premature convergence as other selection strategies. Keep in mind, the goal of a genetic algorithm is to evolve a <code>population</code> of individuals towards a specific target over time, and random selection does not take advantage of the information provided by the fitness values of the individuals. This selection strategy is mainly used for testing purposes in Radiate, but may be useful in some specific scenarios.</p>  Python Rust <pre><code>import radiate as rd\n\nselector = rd.RandomSelector()\n</code></pre> <pre><code>use radiate::*;\n\nlet selector = RandomSelector::new();\n</code></pre>"},{"location":"source/selectors/#steady-state","title":"Steady State","text":"<p>Inputs</p> <ul> <li><code>replacement_count</code>: usize - The number of individuals to replace in the population.</li> </ul> <p>The <code>SteadyStateSelector</code> is a selection strategy that selects individuals from the <code>population</code> based on their fitness values, but with a focus on maintaining a steady state in the <code>population</code>. This means that the selection process is designed to prevent drastic changes in the <code>population</code> from one generation to the next, and to ensure that the best individuals are preserved while still allowing for some degree of exploration and diversity. We do this by coping the original <code>population</code>, then taking <code>replacement_count</code> random individuals from the current <code>population</code> and inserting them at a random index into the resulting <code>population</code>. This helps to maintain a balance between exploration and exploitation in the selection process.</p>  Python Rust <pre><code>import radiate as rd\n\nselector = rd.SteadyStateSelector(replacements=10)\n</code></pre> <pre><code>use radiate::*;\n\nlet selector = SteadyStateSelector::new(10);\n</code></pre>"},{"location":"source/selectors/example/","title":"Example","text":"<p>Let's continue with our example from the previous section - evolving a simple function: finding the best values for <code>y = ax + b</code> where we want to find optimal values for <code>a</code> and <code>b</code>. We'll use the same <code>codec</code> and <code>fitness_function</code> as before, but now we'll incorporate a <code>selector</code> to choose individuals for the next generation.</p>  Python Rust <pre><code>import radiate as rd\n\n# Define a fitness function that uses the decoded values\ndef fitness_function(individual: list[float]) -&gt; float:    \n    # Calculate how well these parameters fit your data\n    a = individual[0]\n    b = individual[1]\n    return calculate_error(a, b)  # Your error calculation here\n\n# Create a codec for two parameters (a and b)\ncodec = rd.FloatCodec.vector(\n    length=2,                  # We need two parameters: a and b\n    init_range=(-1.0, 1.0),    # Start with values between -1 and 1\n    bounds=(-10.0, 10.0)       # Allow evolution to modify the values between -10 and 10\n)\n\n# Use Boltzmann selection for offspring - individuals which\n# will be used to create new individuals through mutation and crossover\noffspring_selector = rd.BoltzmannSelector(temp=4)\n\n# Use tournament selection for survivors - individuals which will \n# be passed down unchanged to the next generation\nsurvivor_selector = rd.TournamentSelector(k=3)\n\n# Create the evolution engine\nengine = rd.GeneticEngine(\n    codec=codec,\n    fitness_func=fitness_function,\n    offspring_selector=offspring_selector,\n    survivor_selector=survivor_selector,\n    # ... other parameters ...\n)\n\n# Run the engine\nresult = engine.run([rd.ScoreLimit(0.01), rd.GenerationsLimit(1000)])\n</code></pre> <pre><code>use radiate::*;\n\n// Define a fitness function that uses the decoded values\nfn fitness_fn(individual: Vec&lt;f32&gt;) -&gt; f32 {\n    let a = individual[0];\n    let b = individual[1];\n    calculate_error(a, b)  // Your error calculation here\n}\n\n// This will produce a Genotype&lt;FloatChromosome&gt; with 1 FloatChromosome which\n// holds 2 FloatGenes (a and b), each with a value between -1.0 and 1.0 and a bound between -10.0 and 10.0\nlet codec = FloatCodec::vector(2, -1.0..1.0).with_bounds(-10.0..10.0);\n\n// Use Boltzmann selection for offspring - individuals which\n// will be used to create new individuals through mutation and crossover\nlet offspring_selector = BoltzmannSelector::new(4.0);\n\n// Use tournament selection for survivors - individuals which will\n// be passed down unchanged to the next generation\nlet survivor_selector = TournamentSelector::new(3);\n\nlet mut engine = GeneticEngine::builder()\n    .codec(codec)\n    .offspring_selector(offspring_selector)\n    .survivor_selector(survivor_selector)\n    .fitness_fn(fitness_fn)\n    // ... other parameters ...\n    .build();\n\n// Run the engine\nlet result = engine.run(|generation| {\n    generation.index() &gt;= 1000 || generation.score().as_f32() &lt;= 0.01\n});\n</code></pre>"}]}